<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[查看页面的内存]]></title>
    <url>%2Fposts%2F8366dd6%2F</url>
    <content type="text"><![CDATA[Performance 允许网页访问某些函数来测量网页和Web应用程序的性能。通过 window.performance 可以查看当前网页的 memory , timing 等一些页面指标。 memory打开控制台，输入 window.performance.memory 三个属性的含义分别是: jsHeapSizeLimit: 堆内存大小限制，单位是 byte。2197815296 / 1024 / 1024 / 1024 = 2.0468G totalJSHeapSize: 总的堆内存大小，单位是 byte。 11204572 / 1024 / 1024 = 10.6855M usedJSHeapSize: 已使用的堆内存大小，单位是 byte。 10790028 / 1024 / 1024 = 10.2901M 有了这几个内存信息，就可以实现一些高级一点的功能。比如内存异常的报警，日志上报等。 demo1234&lt;body&gt; &lt;div class="used"&gt;&lt;/div&gt; &lt;div class="total"&gt;&lt;/div&gt;&lt;/body&gt; 1234567891011function init() &#123; requestAnimationFrame(function cal()&#123; const memory = window.performance.memory; const &#123; totalJSHeapSize, usedJSHeapSize &#125; = memory; document.querySelector('.used').textContent = usedJSHeapSize; document.querySelector('.total').textContent = totalJSHeapSize; requestAnimationFrame(cal); &#125;) &#125; window.addEventListener('DOMContentLoaded', init); 但是结果并不是跟我们想的一样 这几个参数都没有变过。 这是因为 chrome 的安全策略，这些内部信息并没有暴露给外部，想要实时查看的话，只能在启动 chrome 时添加 --enable-precise-memory-info 参数。 --enable-precise-memory-info 关闭当前已开启的 chrome 窗口 在控制台通过以下命令打开 chrome /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --enable-precise-memory-info 这个时候就可以看见这几个属性在实时变化了。 总结 通过 window.performance.memory 可以查看网页的内存信息。 当前想通过 js 获取内存信息，首先需要是 chrome, 而且需要开启 --enable-precise-memory-info。 完]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie]]></title>
    <url>%2Fposts%2F8ae0ba66%2F</url>
    <content type="text"><![CDATA[cookie 是服务器存入浏览器的数据，用于浏览器和服务器之间进行信息交互。 概念用法其实很简单，当服务器需要在页面里放入一些数据时，就可以在响应头里添加 Set-Cookie 属性，浏览器收到响应后就会保存下这些 cookie , 之后的请求中就会携带这些 cookie; 1Set-cookie: &lt;key&gt;=&lt;value&gt; cookie 的一些属性我们用的最多的,包括在 network 面板和 document.cookie 看到的都是 key-value 的形式，但 cookie 还能通过其他一些属性进行更严格的控制。 Max-age 和 Expires看到这两个属性，就应该想到 http缓存 那些东西。Max-Age 和 Expires 给 cookie 加上一个过期时间。 如果 Set-cookie 里没有这两个属性，那么这时候的 cookie 就叫做 会话cookie 。它会随着浏览器的关闭而清除。 Expires 和 Max-Age 同响应头类似，指定一个 绝对时间 或者 以毫秒为单位的相对过期时间。当 cookie 过期后，就会被浏览器清除。 Secure当一个 cookie 设置了 Secure 属性，也就意味着这个 cookie 只能在 https 中传输。 HttpOnly第一眼看见这个属性，可能会疑惑的认为这个属性时控制只能在 http 中进行传输。其实不是，它是限定 cookie 只能被用于传输至服务端。当我们使用 document.cookie 时，无法获取到设置了 HttpOnly 的 cookie 值。 DomainDomain 属性用来设置 cookie 所在的域，如果不指定，默认为当前域，不包含子域名。但如果指定了 Domain 属性，则会 包含子域名。 PathPath 和 Domain 不同，Domain 限制的域名，而 Path 限定了一个域名的哪些路径可以访问到这个 cookie。 1Set-Cookie: name=value; path=/user; 只有访问 /user 路径才会携带这个 cookie 。 todokoa demo 完]]></content>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa源码(一)]]></title>
    <url>%2Fposts%2Fbea7705e%2F</url>
    <content type="text"><![CDATA[首先 koa 是什么 koa是基于Node.js的下一代 web框架 koa 和 express 相比，体积更轻。koa 的 v1 版本中，使用的是 generator 函数来处理复杂的嵌套回调的调用，而在 v2 版本中使用了更为简洁的 async await 语法来处理。今天分析的源码也是基于 v2 版本的。 洋葱圈模型听过 koa ，洋葱圈模型肯定也听过。下图就反映了一个 请求 从 请求 到 响应的整个过程。从一个中间件进入，依次进入后面的中间件，最后在从这个中间件出来。 1234567891011121314151617async A() &#123; A1; await next(); A2;&#125;async B() &#123; B1; await next(); B2;&#125;async C() &#123; C1; await next(); C2;&#125; 在一个中间件的里遇到 next, 请求将会交给下一个中间件处理。下一个中间件处理完，则继续回到之前的中间件，因此在 koa 里，上面代码的执行顺序就是 A1 - B1 - C1 - C2 - B2 - A2; 洋葱圈模型的实现首先先创建一个 app; 12const Koa = require('koa');const app = new Koa(); 在 koa 里，通过 app.use(middleware) 的方式添加中间件。 use 做的事情只是单纯的将 中间件 推入到一个数组内 1this.middleware.push(fn); 之后 app.listen 就创建了一个服务器。 12345listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args);&#125; listen 方法内，同样是调用的 http.createServer ，只是这个函数句柄是 koa 通过 this.callback() 生成的。所以再看看 callback 方法。 123456789callback() &#123; // koa-compose const fn = compose(this.middleware); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; callback 返回了我们需要的函数，函数内部由 this.handleRequest 来响应请求。 12345678handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); &#125; 所以，handleRequest 内部其实是通过之前生成 fnMiddleware 来处理请求。传入 koa 内部合成的 ctx; koa-compose因此，理解 koa 的洋葱圈模型，重点是理解 koa-compose; 贴一下精简过的 koa-compose 的代码 123456789101112131415161718function compose (middleware) &#123; return function (context, next) &#123; let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 通过 koa-compose 生成的函数 fnMiddleware 传入 ctx 。函数内部直接返回了 dispatch(0)。每一次 dispatch 函数的执行都是执行传入的索引对应的中间件。 12let fn = middleware[i]fn(context, dispatch.bind(null, i + 1)); 而洋葱圈的关键就是将 dispatch.bind(null, i + 1) 作为第 i 个中间件的 next 参数。这样在一个中间件的内部调用 next 方法时，实际上会触发下一个中间件的执行。 当执行完最后一个中间件的时候，fn(context, dispatch.bind(null, i + 1)) 返回值会被 resolved ，然后被上一个中间件的 await 捕捉到。]]></content>
      <tags>
        <tag>源码阅读</tag>
        <tag>node</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vscode里调试webpack]]></title>
    <url>%2Fposts%2F6e358f78%2F</url>
    <content type="text"><![CDATA[如何在 vscode 里调试 webpack如果你想了解 webpack 的执行过程，或者调试自己的 webpack plugin 或者 loader。得益于 vscode 强大的 debugger 工具，你只需添加一些配置项即可。 全局添加 command + , 进入偏好设置。 打开 setting.json, 将以下配置项粘贴到配置文件中。 12345678"launch": &#123; "configurations": [&#123; "type": "node", "request": "launch", "name": "Launch Webpack", "program": "$&#123;workspaceFolder&#125;/node_modules/webpack/bin/webpack.js" &#125;]&#125; 之后打开 vscode 的 debugger 工具，就能看到 Launch Webpack 选项了。 添加参数理论上，添加上面的配置就足够了。webpack 会自动去寻找项目根目录下的 webpack.config.js 文件。如果你想指定配置文件，就需要添加对应的参数，参数和 webpack 提供的 cli 参数含义相同。 123"args": [ "--config": "./webpack.config.prod.js"] 添加环境变量添加环境有两种方式，指定一个环境变量文件或者一个配置对象即可。 1"envFile": "$&#123;workspaceFolder&#125;/somedir/filename.env" env 的文件内容就是一段文本。 12NODE_ENV=productionCACHE_PATH=.lib_cache 或者 1234"env": &#123; "NODE_ENV": "production", "CACHE_PATH": ".cache"&#125; 本地添加就是将调试配置添加到当前文件夹。 添加配置 -&gt; node.js ，配置项同上。之后在当前目录下就会生成一个 .vscode 文件夹了。 debugging的使用可以参考官方 debugging文档 完。 附上一份完整的配置。 123456789101112"launch": &#123; "configurations": [&#123; "type": "node", "request": "launch", "name": "Launch Webpack", "program": "$&#123;workspaceFolder&#125;/node_modules/webpack/bin/webpack.js", "args": [ "--config", "$&#123;workspaceFolder&#125;/webpack.config.js" ], "env" : &#123; "NODE_ENV" : "production" &#125; &#125;]&#125;]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】对象扩展符简易指南]]></title>
    <url>%2Fposts%2Fadc6686%2F</url>
    <content type="text"><![CDATA[合并多个 Javascript 对象是常见的工作，但不好的是，至少到目前，Javascript 仍然没有一种方便的方法来完成这个工作。至少现在是这样。 在 ES5 时代，你可以使用 Lodash 的 _.extend(target, [sources]) 方法，而 ES2015 则引入了 Object.assign(target, [sources]) 方法。 幸运的是，对象扩展符 (an ECMASript proposal at stage 3) 是一个很大的进步，提供了简单方便的如下简介方便的语法。 Run demo 12345678910const cat = &#123; legs: 4, sound: 'meow'&#125;;const dog = &#123; ...cat, sound: 'woof'&#125;;console.log(dog); // =&gt; &#123; legs: 4, sounds: 'woof' &#125; 上面的例子中，...cat 复制 cat 的属性到一个新对象 dog 中，cat 中原来的属性 sound 被覆盖，最终值为 woof。 本篇文章将介绍对象 spread 和 rest 语法。包括如何实现对象克隆，对象合并，以及如何覆盖属性值。 下面是关于可枚举属性的简单和概括，以及如何分辨对象自有属性和继承属性。 1. 可枚举以及自有属性Javascript 里的对象是键值对的组合。 键名通常是一个字符串或者一个 symbol 。值可以是一个原始类型的值(string, boolean, number, undefined 或者 null)，一个对象或者一个函数。 下面这个例子将通过对象字面量语法创建一个对象。 1234const person = &#123; name: 'Dave', surname: 'Bowman'&#125;; person 这个对象描述了一个人的名和姓氏。 1.1 可枚举属性描述一个属性有几种描述符，如 writable、enumerable 和configurable 。你可以看这篇文章Object properties in JavaScript了解更多细节。 Enumerable 描述符是一个布尔值，表示这个属性是否可以被枚举。 你可以通过 Object.keys() 方法来枚举一个对象的自有属性和可枚举属性，通过 for..in 语句来枚举所有可枚举的属性。 以对象字面量的形式创建对象 { prop1: &#39;val1&#39;, prop2: &#39;val2&#39; } 时显式声明的属性都是可枚举的。接下来看看之前创建的 person 对象有哪些可枚举的属性。 Run demo 12const keys = Object.keys(person); console.log(keys); // =&gt; ['name', 'surname'] .name 和 .surname 是 person 对象的可枚举属性 接下来是有趣的一部分。对象扩展符复制了原对象的所有可枚举属性。 Run demo 1console.log(&#123; ...person &#125;; // =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125; 下面我们在 person 对象上创建一个不可枚举属性 .age。 Run demo 12345678910Object.defineProperty(person, 'age', &#123; enumerable: false, // Make the property non-enumerable value: 25&#125;);console.log(person['age']); // =&gt; 25const clone = &#123; ...person&#125;;console.log(clone); // =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125; 目标对象 clone 从源对象 person 上创建了可枚举属性 .name 和 .surname ，但是不可枚举属性 .age 则被忽略掉。 1.2 自有属性Javascript 内有原型继承机制，因此一个对象上既有 自有属性，也有从继承属性。 对象字面量显式声明的属性都是自有属性，存在于原型链上的属性都是 继承 属性。 下面将创建一个 personB 对象，并将 person 对象设置成其原型对象。 Run demo 12345678910const personB = Object.create(person, &#123; profession: &#123; value: 'Astronaut', enumerable: true &#125;&#125;);console.log(personB.hasOwnProperty('profession')); // =&gt; true console.log(personB.hasOwnProperty('name')); // =&gt; false console.log(personB.hasOwnProperty('surname')); // =&gt; false 现在 personB 上有自有的 .profession 属性，以及从原型对象 person 上继承来的 .name 和 .surname 属性。 对象扩展符从源对象上复制自有属性，而会忽略继承的属性 Run demo 1234const cloneB = &#123; ...personB&#125;;console.log(cloneB); // =&gt; &#123; profession: 'Astronaut' &#125; ...personB 只从 personB 上复制了 .profession 这个自有属性，而继承属性 .name 和 .surname 则被忽略。 总结： 对象扩展符号只会从源对象上复制 自有和可枚举属性，这和 Object.keys() 方法的返回值一样。 2. 对象扩展属性在对象字面量里，对象扩展符将源对象里的自有属性和可枚举属性复制进目标对象内。 1234const targetObject = &#123; ...sourceObject, property: 'Value'&#125;; 顺便说一下，很多时候，对象扩展符与 Object.assign() 等价，上面的代码也可以用这样实现： 12345const targetObject = Object.assign( &#123; &#125;, sourceObject, &#123; property: 'Value' &#125;); 一个对象字面量里可以使用多个对象扩展符，与普通的属性声明同时使用： 1234567const targetObject = &#123; ...sourceObject1, property1: 'Value 1', ...sourceObject2, ...sourceObject3, property2: 'Value 2'&#125;; 2.1 对象扩展规则：后面的属性会覆盖前面的当同时扩展多个对象时，这个对象内可能会存在同名属性，那么最终生成的对象的属性值是怎么计算的，规则很简单：后扩展的属性会覆盖之前扩展的属性。 来看一些简单的例子。下面的代码会实例化一只 cat 。 1234const cat = &#123; sound: 'meow', legs: 4&#125;; 现在我们要变一个魔术，将这只猫变成一只狗，注意 .sound 属性值如何变化。 Run demo 1234567const dog = &#123; ...cat, ...&#123; sound: 'woof' // `&lt;----- Overwrites cat.sound &#125;&#125;;console.log(dog); // =&gt;` &#123; sound: 'woof', legs: 4 &#125; 后面声明的 ·woof· 属性值覆盖了前面的在 cat 对象声明的属性值 &#39;meow&#39; , 符合之前所说的规则: 对于同名属性，后声明的值覆盖先声明的值。 这个规则同样适用于对象的初始化 Run demo 12345const anotherDog = &#123; ...cat, sound: 'woof' // `&lt;---- Overwrites cat.sound&#125;;console.log(anotherDog); // =&gt;` &#123; sound: 'woof', legs: 4 &#125; 上面代码里，sound: &#39;woof&#39; 同样覆盖了之前声明的 &#39; meow&#39; 值。 现在，交换一下扩展对象的位置，输出了不同的结果。 Run demo 1234567const stillCat = &#123; ...&#123; sound: 'woof' // `&lt;---- Is overwritten by cat.sound &#125;, ...cat&#125;;console.log(stillCat); // =&gt;` &#123; sound: 'meow', legs: 4 &#125; cat 对象仍然是 cat 对象。虽然第一个源对象内的 .sound 属性值是 &#39;woof&#39; ，但是被之后 cat 对象的 &#39;meow&#39; 覆盖。 普通属性和对象扩展的相对位置非常重要，这将直接影响到对象克隆，对象合并，以及填充默认属性的结果。 下面分别详细介绍。 2.2 克隆对象用对象扩展符克隆一个对象非常简洁，下面的代码克隆了一个 bird 对象。 Run demo 1234567891011const bird = &#123; type: 'pigeon', color: 'white'&#125;;const birdClone = &#123; ...bird&#125;;console.log(birdClone); // =&gt; &#123; type: 'pigeon', color: 'white' &#125; console.log(bird === birdClone); // =&gt; false ...bird 将 bird 对象的自有和可枚举属性复制到目标对象 birdClone 内。 虽然克隆看起来很简单，但仍然要注意其中的几个细微之处。 浅复制对象扩展只是对对象进行了 浅复制, 只有对象自身被复制，而嵌套的对象结构 没有被复制。 laptop 对象有一个嵌套对象 laptop.screen。现在我们来克隆 laptop对象来看看其内部的嵌套对象怎么变化。 Run demo 12345678910111213const laptop = &#123; name: 'MacBook Pro', screen: &#123; size: 17, isRetina: true &#125;&#125;;const laptopClone = &#123; ...laptop&#125;;console.log(laptop === laptopClone); // =&gt; false console.log(laptop.screen === laptopClone.screen); // =&gt; true 第一个比较语句 laptop === laptopClone 的值为 false, 说明主对象被正确克隆。 然而 laptop.screen === laptopClone.screen 的计算结果为 true ，说明 laptopClone.screen 没有被复制，而是 laptop.screen 和 laptopClone.screen 引用了同一个嵌套对象。 好的一点是，你可以在对象的任何一层使用对象扩展符，只需要再多做一点工作就同样可以克隆一个嵌套对象。 Run demo 123456789const laptopDeepClone = &#123; ...laptop, screen: &#123; ...laptop.screen &#125;&#125;;console.log(laptop === laptopDeepClone); // =&gt; false console.log(laptop.screen === laptopDeepClone.screen); // =&gt; false 使用 ...laptop.screen 使嵌套对象也被克隆，现在 laptopDeepClone 完全克隆了 laptop。 原型失去了下面的代码声明了一个 Game 类，并创造了一个 doom实例。 Run demo 1234567891011121314class Game &#123; constructor(name) &#123; this.name = name; &#125; getMessage() &#123; return `I like $&#123;this.name&#125;!`; &#125;&#125;const doom = new Game('Doom'); console.log(doom instanceof Game); // =&gt; true console.log(doom.name); // =&gt; "Doom" console.log(doom.getMessage()); // =&gt; "I like Doom!" 现在我们克隆一个通过构造函数创建的 doom 实例，结果可能与你想的不同。 Run demo 12345678const doomClone = &#123; ...doom&#125;;console.log(doomClone instanceof Game); // =&gt; false console.log(doomClone.name); // =&gt; "Doom" console.log(doomClone.getMessage()); // TypeError: doomClone.getMessage is not a function ...doom 将自有属性 .name 属性复制到 doomClone 内。 doomClone 现在只是一个普通的 JavaScript 对象，它的原型是 Object.prototype 而不是预想中的Game.prototype。对象扩展不保留源对象的原型。 因此调用 doomClone.getMessage() 方法会抛出一个 TypeError 错误，因此 doomClone 没有继承 getMessage() 方法。 当然我们可以手动在克隆对象上加上 __proto__ 属性来结局这个问题。 Run demo 12345678const doomFullClone = &#123; ...doom, __proto__: Game.prototype&#125;;console.log(doomFullClone instanceof Game); // =&gt; true console.log(doomFullClone.name); // =&gt; "Doom" console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 对象字面量内部的 __proto__ 属性确保了 doomFullClone 的原型为 Game.prototype。 尽量不要尝试这种方法。__proto__ 属性已经废弃，这里使用它只是为了论证前面的观点。 对象扩展的目的是以浅复制的方式扩展自有和可枚举属性，因此不保留源对象的原型似乎也说得过去。 例外，这里用 Object.assign() 来克隆 doom 更加合理。 Run demo 12345const doomFullClone = Object.assign(new Game(), doom);console.log(doomFullClone instanceof Game); // =&gt; true console.log(doomFullClone.name); // =&gt; "Doom" console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 这样，就保留了原型。 2.3 不可变对象更新在一个应用里，同一个对象可能会用于多个地方，直接修改这个对象会带来意想不到的副作用，并且追踪这个修改及其困难。 一个好的方式是使操作不可变。不可变性使修改对象更为可控，更有利于书写。pure functions。即时是在复杂的应用场景，由于单向数据流，更容易确定对象的来源和改变的原因。 使用对象扩展能更方便的以不可变方式来修改一个对象。假设现在你有一个对象来描述一本书的信息。 123456const book = &#123; name: 'JavaScript: The Definitive Guide', author: 'David Flanagan', edition: 5, year: 2008&#125;; 现在，书第六版即将出版，我们用对象扩展的处理这个场景。 Run demo 123456789101112131415const newerBook = &#123; ...book, edition: 6, // &lt;----- Overwrites book.edition year: 2011 // &lt;----- Overwrites book.year&#125;;console.log(newerBook); /*&#123; name: 'JavaScript: The Definitive Guide', author: 'David Flanagan', edition: 6, year: 2011&#125;*/ newerBook 对象内的 ...book 扩展了 book 对象的属性。手动创建的可枚举属性 editon: 6 和 year: 2011 更新了原有的同名属性。 重要的属性一般在末尾来指定，以便覆盖前面已经创建的同名属性。 newerBook 是一个更新了某些属性的新的对象，并且我们没有改变原有的 book 对象，满足了不可变性的要求。 2.4 合并对象使用对象扩展符合并多个对象非常简单。 现在我们合并3个对象来创建一个“合成对象”。 Run demo 12345678910111213141516const part1 = &#123; color: 'white'&#125;;const part2 = &#123; model: 'Honda'&#125;;const part3 = &#123; year: 2005&#125;;const car = &#123; ...part1, ...part2, ...part3&#125;;console.log(car); // &#123; color: 'white', model: 'Honda', year: 2005 &#125; 上面的例子中，我们使用 part1、part2、part3 3个对象合并成了一个 car 对象。 另外，不要忘了之前讲的规则，后面的属性值会覆盖前面的同名属性值。这是我们合并有同名属性对象的计算依据。 现在我们稍微改变一下之前的代码。给 part1 和 part3 增加一个 .configuration 属性。 Run demo 1234567891011121314151617181920212223242526const part1 = &#123; color: 'white', configuration: 'sedan'&#125;;const part2 = &#123; model: 'Honda'&#125;;const part3 = &#123; year: 2005, configuration: 'hatchback'&#125;;const car = &#123; ...part1, ...part2, ...part3 // &lt;--- part3.configuration overwrites part1.configuration&#125;;console.log(car); /*&#123; color: 'white', model: 'Honda', year: 2005, configuration: 'hatchback' `&lt;--- part3.configuration&#125;*/ ...part1 将 configuration 属性设置成了 &#39;sedan&#39;。然而之后的扩展符 ...part3 覆盖了之前的同名 .configuration，最终生成的对象值为 &#39;hatchback&#39;。 2.5 给对象设置默认值一个对象在程序运行时可能会有多套不同的属性值，有些属性可能会被设置，有些则可能被忽略。 这种情况通常发生在一个配置对象上。用户可以指定一个重要的属性值，不重要的属性则使用默认值。 现在我们来实现一个 multline(str, config) 方法，将str 按照给定的长度分割成多行。 config 对象接受下面3个可选的参数。 width: 分割的字符长度，默认是 10。 newLine: 添加到每一行结尾的的字符， 默认是 \n。 indent: 每一行开头的缩进符，默认是空字符串 &#39;&#39;。 下面是一些 multline() 运行的例子。 Run demo 1234567891011multiline('Hello World!'); // =&gt;` 'Hello Worl\nd!'multiline('Hello World!', &#123; width: 6 &#125;); // =&gt; 'Hello \nWorld!'multiline('Hello World!', &#123; width: 6, newLine: '*' &#125;); // =&gt; 'Hello *World!'multiline('Hello World!', &#123; width: 6, newLine: '*', indent: '_' &#125;); // =&gt; '_Hello *_World!' config 参数接受几套不同的属性值：你可以指定1，2或者3个属性值，甚至不指定任何一个属性。 使用对象扩展语法来填充配置对象非常简单，在对象字面量里，首先扩展默认值对象，然后是配置对象，如下所示： Run demo 12345678910111213141516function multiline(str, config = &#123;&#125;) &#123; const defaultConfig = &#123; width: 10, newLine: '\n', indent: '' &#125;; const safeConfig = &#123; ...defaultConfig, ...config &#125;; let result = ''; // Implementation of multiline() using // safeConfig.width, safeConfig.newLine, safeConfig.indent // ... return result;&#125; 我们来仔细了解一下 safeConfig 对象。 ...defaultConfig 首先将默认对象的属性复制，随后，...config 里用户自定义的值覆盖了之前的默认属性值。 这样 safeConfig 值就拥有了所有 multiline() 需要的配置参数。无论调用 multiline() 函数时，输入的 config 是否缺失了某些属性，都可以保证 safeConfig 拥有所有的必备参数。 显而易见，对象扩展实现了我们想要的 给对象设置默认值。 2.6 更加深入对象扩展更有用的一点是用于嵌套对象，当更新一个复杂对象时，更具有可读性，比 Object.assign() 更值得推荐。 下面的 box 对象定义一个盒子及盒子内的物品。 12345678const box = &#123; color: 'red', size: &#123; width: 200, height: 100 &#125;, items: ['pencil', 'notebook']&#125;; box.size 描述了这个盒子的尺寸，box.items 列举了盒子内的物品。 为了使盒子看起来更高，我们增大 box.size.height 的值，只需要在嵌套对象上使用 对象扩展符。 Run demo 123456789101112131415161718const biggerBox = &#123; ...box, size: &#123; ...box.size, height: 200 &#125;&#125;;console.log(biggerBox); /*&#123; color: 'red', size: &#123; width: 200, height: 200 &lt;----- Updated value &#125;, items: ['pencil', 'notebook']&#125;*/ ...box 确保了 biggerBox 获得了 源对象 box 上的全部属性。 更新 box.size 的 height 值需要额外一个 {...box.size, height: 200} 对象，该对象接收 box.size 的全部属性，并将 height 值更新至 200。 只需要一个语句就能更新对象的多处属性。 现在如果我们还想把颜色改成 black ,增加盒子的宽度到 400, 并且再放一把尺子到盒子内，应该怎么办？同样很简单。 Run demo 1234567891011121314151617181920212223const blackBox = &#123; ...box, color: 'black', size: &#123; ...box.size, width: 400 &#125;, items: [ ...box.items, 'ruler' ]&#125;;console.log(blackBox); /*&#123; color: 'black', &lt;----- Updated value size: &#123; width: 400, &lt;----- Updated value height: 100 &#125;, items: ['pencil', 'notebook', 'ruler'] `&lt;----- A new item ruler&#125;*/ 2.7 扩展 undefined、null 和 原始类型值如果在 undefined、null 和 原始类型值 上使用原始类型的值，不会复制任何属性，也不会抛出错误，只是简单的返回一个空对象。 Run demo 1234567const nothing = undefined; const missingObject = null; const two = 2;console.log(&#123; ...nothing &#125;); // =&gt; &#123; &#125; console.log(&#123; ...missingObject &#125;); // =&gt; &#123; &#125; console.log(&#123; ...two &#125;); // =&gt; &#123; &#125; 如上所示：从 nothing, missingObject 和 two不会复制任何属性。 当然，这只是一个演示，毕竟根本没有理由在一个原始类型的值上面使用对象扩展符。 3. 剩余属性当使用解构赋值将对象的属性值赋值给变量后，剩余的属性值将会被集合进一个剩余对象内。 下面的代码演示了怎么使用 rest 属性。 Run demo 12345678910const style = &#123; width: 300, marginLeft: 10, marginRight: 30&#125;;const &#123; width, ...margin &#125; = style;console.log(width); // =&gt; 300 console.log(margin); // =&gt; &#123; marginLeft: 10, marginRight: 30 &#125; 通过解构赋值，我们定义了一个新的变量 width ，并将它的值设置为 style.width。而解构赋值声明内的 ...margin 则获得了 style 对象的其余属性，margin 对象获取了 marginLeft 和 marginRight 属性。 rest 操作符同样只会获取自有属性和可枚举属性。 注意，在解构赋值内，rest 操作符只能放到最后，因此 const { ...margin , width } = style 无效，并会抛出一个 SyntaxError: Rest element must be last element 错误。 4. 结论对象扩展需要以下几点： 它只会提取对象的自有属性和可枚举属性 后定义的属性值会覆盖之前定义过的同名属性值 同时，对象扩展使用上方便简洁，能更好的处理嵌套对象，保持不可变性，在实现对象克隆和填充默认属性值上也使用方便。 而 rest 操作符在解构赋值时可以收集剩余的属性。]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之 Symbol]]></title>
    <url>%2Fposts%2F9ced4e66%2F</url>
    <content type="text"><![CDATA[Symbol 是 ES6 增加的第7种数据类型，也是第6种原始数据类型。symbol 值用来创建匿名的对象属性，同时也是唯一的，不会与其他属性名冲突。 创建一个 symbol 值Symbol 是一个函数，调用这个函数即创建了一个 symbol 值。 12typeof Symbol //functionvar sym = Symbol() 但是 Symbol 不是一个构造函数，使用 new 来创建，会抛出错误 1var sym = new Symbol() // TypeError: Symbol is not a constructor Symbol 函数可以接受一个参数，用于描述这个 symbol ，但是也仅仅是用于描述而已调用 toSring 方法可以读取到这个描述 12var sym1 = Symbol('hello world')console.log(sym1) // Symbol(hello world) 即使传入完全一样的描述，所创建的 symbol 也是不相同的 123var sym1 = Symbol('hello world')var sym2 = Symbol('hello world')console.log(sym1 === sym2) // false 使用 symbolsymbol 用于对象属性时，不能使用点字符，只能用于计算属性 123var obj = &#123;&#125;var sym = Symbol('hello world')obj[sym] = 'hello Symbol' 重复使用一个 symbol前面说过 每一个 symbol 值都是独一无二的，但是有时候我们也需要共用一个 symbol ，这时候就需要用到 Symbol.for 这一方法了。 Symbol.for 方法接受一个 key 参数，根据这个 key 在全局的 Symbol 注册值中查找，如果之前已经通过 Symbol.for 方法和该key 创建过，那么就返回这个已经创建的 symbol 值，否则以 key 值创建一个，并注册一个全局值。下面这个例子可以比较 Symbol 和 Symbol.for 的不同 1234567var sym1 = Symbol('hello world')var sym2 = Symbol('hello world')console.log(sym1 === sym2) // falsevar sym3 = Symbol.for('global')var sym4 = Symbol.for('global')console.log(sym3 === sym4) // true 当要创建 sym4 时，由于之前 已经用 global 这个值创建了 sym3 ，因此会直接把 sym3 的值赋给 sym4 和 Symbol.for 对应的另一个方法是 Symbol.keyForSymbol.keyFor 方法接受一个 symbol 值作为参数，返回对应的 key 值 1234// 接上例console.log(Symbol.keyFor(sym3)) // globalconsole.log(Symbol.keyFor(sym4)) // globalconsole.log(Symbol.keyFor(sym1)) // undefined 基本上，Symbol 了解这些就已经足够日常使用了。剩下的一些零零散散的知识和一些 Well-known Symbol 之后抽空看看。]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
