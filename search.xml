<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用的api (持续更新)]]></title>
    <url>%2Fposts%2Fcaa38fce%2F</url>
    <content type="text"><![CDATA[汇总一些常用的 API。 1. 手机号码归属地 https://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel= request https://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=1820142**** response 123456789__GetZoneResult_ = &#123; mts:'1820142', province:'北京', catName:'中国移动', telString:'1820142****', areaVid:'29400', ispVid:'3236139', carrier:'北京移动'&#125;]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】对象扩展符简易指南]]></title>
    <url>%2Fposts%2Fadc6686%2F</url>
    <content type="text"><![CDATA[合并多个 Javascript 对象是常见的工作，但不好的是，至少到目前，Javascript 仍然没有一种方便的方法来完成这个工作。至少现在是这样。 在 ES5 时代，你可以使用 Lodash 的 _.extend(target, [sources]) 方法，而 ES2015 则引入了 Object.assign(target, [sources]) 方法。 幸运的是，对象扩展符 (an ECMASript proposal at stage 3) 是一个很大的进步，提供了简单方便的如下简介方便的语法。 Run demo 12345678910const cat = &#123; legs: 4, sound: 'meow'&#125;;const dog = &#123; ...cat, sound: 'woof'&#125;;console.log(dog); // =&gt; &#123; legs: 4, sounds: 'woof' &#125; 上面的例子中，...cat 复制 cat 的属性到一个新对象 dog 中，cat 中原来的属性 sound 被覆盖，最终值为 woof。 本篇文章将介绍对象 spread 和 rest 语法。包括如何实现对象克隆，对象合并，以及如何覆盖属性值。 下面是关于可枚举属性的简单和概括，以及如何分辨对象自有属性和继承属性。 1. 可枚举以及自有属性Javascript 里的对象是键值对的组合。 键名通常是一个字符串或者一个 symbol 。值可以是一个原始类型的值(string, boolean, number, undefined 或者 null)，一个对象或者一个函数。 下面这个例子将通过对象字面量语法创建一个对象。 1234const person = &#123; name: 'Dave', surname: 'Bowman'&#125;; person 这个对象描述了一个人的名和姓氏。 1.1 可枚举属性描述一个属性有几种描述符，如 writable、enumerable 和configurable 。你可以看这篇文章Object properties in JavaScript了解更多细节。 Enumerable 描述符是一个布尔值，表示这个属性是否可以被枚举。 你可以通过 Object.keys() 方法来枚举一个对象的自有属性和可枚举属性，通过 for..in 语句来枚举所有可枚举的属性。 以对象字面量的形式创建对象 { prop1: &#39;val1&#39;, prop2: &#39;val2&#39; } 时显式声明的属性都是可枚举的。接下来看看之前创建的 person 对象有哪些可枚举的属性。 Run demo 12const keys = Object.keys(person); console.log(keys); // =&gt; ['name', 'surname'] .name 和 .surname 是 person 对象的可枚举属性 接下来是有趣的一部分。对象扩展符复制了原对象的所有可枚举属性。 Run demo 1console.log(&#123; ...person &#125;; // =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125; 下面我们在 person 对象上创建一个不可枚举属性 .age。 Run demo 12345678910Object.defineProperty(person, 'age', &#123; enumerable: false, // Make the property non-enumerable value: 25&#125;);console.log(person['age']); // =&gt; 25const clone = &#123; ...person&#125;;console.log(clone); // =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125; 目标对象 clone 从源对象 person 上创建了可枚举属性 .name 和 .surname ，但是不可枚举属性 .age 则被忽略掉。 1.2 自有属性Javascript 内有原型继承机制，因此一个对象上既有 自有属性，也有从继承属性。 对象字面量显式声明的属性都是自有属性，存在于原型链上的属性都是 继承 属性。 下面将创建一个 personB 对象，并将 person 对象设置成其原型对象。 Run demo 12345678910const personB = Object.create(person, &#123; profession: &#123; value: 'Astronaut', enumerable: true &#125;&#125;);console.log(personB.hasOwnProperty('profession')); // =&gt; true console.log(personB.hasOwnProperty('name')); // =&gt; false console.log(personB.hasOwnProperty('surname')); // =&gt; false 现在 personB 上有自有的 .profession 属性，以及从原型对象 person 上继承来的 .name 和 .surname 属性。 对象扩展符从源对象上复制自有属性，而会忽略继承的属性 Run demo 1234const cloneB = &#123; ...personB&#125;;console.log(cloneB); // =&gt; &#123; profession: 'Astronaut' &#125; ...personB 只从 personB 上复制了 .profession 这个自有属性，而继承属性 .name 和 .surname 则被忽略。 总结： 对象扩展符号只会从源对象上复制 自有和可枚举属性，这和 Object.keys() 方法的返回值一样。 2. 对象扩展属性在对象字面量里，对象扩展符将源对象里的自有属性和可枚举属性复制进目标对象内。 1234const targetObject = &#123; ...sourceObject, property: 'Value'&#125;; 顺便说一下，很多时候，对象扩展符与 Object.assign() 等价，上面的代码也可以用这样实现： 12345const targetObject = Object.assign( &#123; &#125;, sourceObject, &#123; property: 'Value' &#125;); 一个对象字面量里可以使用多个对象扩展符，与普通的属性声明同时使用： 1234567const targetObject = &#123; ...sourceObject1, property1: 'Value 1', ...sourceObject2, ...sourceObject3, property2: 'Value 2'&#125;; 2.1 对象扩展规则：后面的属性会覆盖前面的当同时扩展多个对象时，这个对象内可能会存在同名属性，那么最终生成的对象的属性值是怎么计算的，规则很简单：后扩展的属性会覆盖之前扩展的属性。 来看一些简单的例子。下面的代码会实例化一只 cat 。 1234const cat = &#123; sound: 'meow', legs: 4&#125;; 现在我们要变一个魔术，将这只猫变成一只狗，注意 .sound 属性值如何变化。 Run demo 1234567const dog = &#123; ...cat, ...&#123; sound: 'woof' // `&lt;----- Overwrites cat.sound &#125;&#125;;console.log(dog); // =&gt;` &#123; sound: 'woof', legs: 4 &#125; 后面声明的 ·woof· 属性值覆盖了前面的在 cat 对象声明的属性值 &#39;meow&#39; , 符合之前所说的规则: 对于同名属性，后声明的值覆盖先声明的值。 这个规则同样适用于对象的初始化 Run demo 12345const anotherDog = &#123; ...cat, sound: 'woof' // `&lt;---- Overwrites cat.sound&#125;;console.log(anotherDog); // =&gt;` &#123; sound: 'woof', legs: 4 &#125; 上面代码里，sound: &#39;woof&#39; 同样覆盖了之前声明的 &#39; meow&#39; 值。 现在，交换一下扩展对象的位置，输出了不同的结果。 Run demo 1234567const stillCat = &#123; ...&#123; sound: 'woof' // `&lt;---- Is overwritten by cat.sound &#125;, ...cat&#125;;console.log(stillCat); // =&gt;` &#123; sound: 'meow', legs: 4 &#125; cat 对象仍然是 cat 对象。虽然第一个源对象内的 .sound 属性值是 &#39;woof&#39; ，但是被之后 cat 对象的 &#39;meow&#39; 覆盖。 普通属性和对象扩展的相对位置非常重要，这将直接影响到对象克隆，对象合并，以及填充默认属性的结果。 下面分别详细介绍。 2.2 克隆对象用对象扩展符克隆一个对象非常简洁，下面的代码克隆了一个 bird 对象。 Run demo 1234567891011const bird = &#123; type: 'pigeon', color: 'white'&#125;;const birdClone = &#123; ...bird&#125;;console.log(birdClone); // =&gt; &#123; type: 'pigeon', color: 'white' &#125; console.log(bird === birdClone); // =&gt; false ...bird 将 bird 对象的自有和可枚举属性复制到目标对象 birdClone 内。 虽然克隆看起来很简单，但仍然要注意其中的几个细微之处。 浅复制对象扩展只是对对象进行了 浅复制, 只有对象自身被复制，而嵌套的对象结构 没有被复制。 laptop 对象有一个嵌套对象 laptop.screen。现在我们来克隆 laptop对象来看看其内部的嵌套对象怎么变化。 Run demo 12345678910111213const laptop = &#123; name: 'MacBook Pro', screen: &#123; size: 17, isRetina: true &#125;&#125;;const laptopClone = &#123; ...laptop&#125;;console.log(laptop === laptopClone); // =&gt; false console.log(laptop.screen === laptopClone.screen); // =&gt; true 第一个比较语句 laptop === laptopClone 的值为 false, 说明主对象被正确克隆。 然而 laptop.screen === laptopClone.screen 的计算结果为 true ，说明 laptopClone.screen 没有被复制，而是 laptop.screen 和 laptopClone.screen 引用了同一个嵌套对象。 好的一点是，你可以在对象的任何一层使用对象扩展符，只需要再多做一点工作就同样可以克隆一个嵌套对象。 Run demo 123456789const laptopDeepClone = &#123; ...laptop, screen: &#123; ...laptop.screen &#125;&#125;;console.log(laptop === laptopDeepClone); // =&gt; false console.log(laptop.screen === laptopDeepClone.screen); // =&gt; false 使用 ...laptop.screen 使嵌套对象也被克隆，现在 laptopDeepClone 完全克隆了 laptop。 原型失去了下面的代码声明了一个 Game 类，并创造了一个 doom实例。 Run demo 1234567891011121314class Game &#123; constructor(name) &#123; this.name = name; &#125; getMessage() &#123; return `I like $&#123;this.name&#125;!`; &#125;&#125;const doom = new Game('Doom'); console.log(doom instanceof Game); // =&gt; true console.log(doom.name); // =&gt; "Doom" console.log(doom.getMessage()); // =&gt; "I like Doom!" 现在我们克隆一个通过构造函数创建的 doom 实例，结果可能与你想的不同。 Run demo 12345678const doomClone = &#123; ...doom&#125;;console.log(doomClone instanceof Game); // =&gt; false console.log(doomClone.name); // =&gt; "Doom" console.log(doomClone.getMessage()); // TypeError: doomClone.getMessage is not a function ...doom 将自有属性 .name 属性复制到 doomClone 内。 doomClone 现在只是一个普通的 JavaScript 对象，它的原型是 Object.prototype 而不是预想中的Game.prototype。对象扩展不保留源对象的原型。 因此调用 doomClone.getMessage() 方法会抛出一个 TypeError 错误，因此 doomClone 没有继承 getMessage() 方法。 当然我们可以手动在克隆对象上加上 __proto__ 属性来结局这个问题。 Run demo 12345678const doomFullClone = &#123; ...doom, __proto__: Game.prototype&#125;;console.log(doomFullClone instanceof Game); // =&gt; true console.log(doomFullClone.name); // =&gt; "Doom" console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 对象字面量内部的 __proto__ 属性确保了 doomFullClone 的原型为 Game.prototype。 尽量不要尝试这种方法。__proto__ 属性已经废弃，这里使用它只是为了论证前面的观点。 对象扩展的目的是以浅复制的方式扩展自有和可枚举属性，因此不保留源对象的原型似乎也说得过去。 例外，这里用 Object.assign() 来克隆 doom 更加合理。 Run demo 12345const doomFullClone = Object.assign(new Game(), doom);console.log(doomFullClone instanceof Game); // =&gt; true console.log(doomFullClone.name); // =&gt; "Doom" console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 这样，就保留了原型。 2.3 不可变对象更新在一个应用里，同一个对象可能会用于多个地方，直接修改这个对象会带来意想不到的副作用，并且追踪这个修改及其困难。 一个好的方式是使操作不可变。不可变性使修改对象更为可控，更有利于书写。pure functions。即时是在复杂的应用场景，由于单向数据流，更容易确定对象的来源和改变的原因。 使用对象扩展能更方便的以不可变方式来修改一个对象。假设现在你有一个对象来描述一本书的信息。 123456const book = &#123; name: 'JavaScript: The Definitive Guide', author: 'David Flanagan', edition: 5, year: 2008&#125;; 现在，书第六版即将出版，我们用对象扩展的处理这个场景。 Run demo 123456789101112131415const newerBook = &#123; ...book, edition: 6, // &lt;----- Overwrites book.edition year: 2011 // &lt;----- Overwrites book.year&#125;;console.log(newerBook); /*&#123; name: 'JavaScript: The Definitive Guide', author: 'David Flanagan', edition: 6, year: 2011&#125;*/ newerBook 对象内的 ...book 扩展了 book 对象的属性。手动创建的可枚举属性 editon: 6 和 year: 2011 更新了原有的同名属性。 重要的属性一般在末尾来指定，以便覆盖前面已经创建的同名属性。 newerBook 是一个更新了某些属性的新的对象，并且我们没有改变原有的 book 对象，满足了不可变性的要求。 2.4 合并对象使用对象扩展符合并多个对象非常简单。 现在我们合并3个对象来创建一个“合成对象”。 Run demo 12345678910111213141516const part1 = &#123; color: 'white'&#125;;const part2 = &#123; model: 'Honda'&#125;;const part3 = &#123; year: 2005&#125;;const car = &#123; ...part1, ...part2, ...part3&#125;;console.log(car); // &#123; color: 'white', model: 'Honda', year: 2005 &#125; 上面的例子中，我们使用 part1、part2、part3 3个对象合并成了一个 car 对象。 另外，不要忘了之前讲的规则，后面的属性值会覆盖前面的同名属性值。这是我们合并有同名属性对象的计算依据。 现在我们稍微改变一下之前的代码。给 part1 和 part3 增加一个 .configuration 属性。 Run demo 1234567891011121314151617181920212223242526const part1 = &#123; color: 'white', configuration: 'sedan'&#125;;const part2 = &#123; model: 'Honda'&#125;;const part3 = &#123; year: 2005, configuration: 'hatchback'&#125;;const car = &#123; ...part1, ...part2, ...part3 // &lt;--- part3.configuration overwrites part1.configuration&#125;;console.log(car); /*&#123; color: 'white', model: 'Honda', year: 2005, configuration: 'hatchback' `&lt;--- part3.configuration&#125;*/ ...part1 将 configuration 属性设置成了 &#39;sedan&#39;。然而之后的扩展符 ...part3 覆盖了之前的同名 .configuration，最终生成的对象值为 &#39;hatchback&#39;。 2.5 给对象设置默认值一个对象在程序运行时可能会有多套不同的属性值，有些属性可能会被设置，有些则可能被忽略。 这种情况通常发生在一个配置对象上。用户可以指定一个重要的属性值，不重要的属性则使用默认值。 现在我们来实现一个 multline(str, config) 方法，将str 按照给定的长度分割成多行。 config 对象接受下面3个可选的参数。 width: 分割的字符长度，默认是 10。 newLine: 添加到每一行结尾的的字符， 默认是 \n。 indent: 每一行开头的缩进符，默认是空字符串 &#39;&#39;。 下面是一些 multline() 运行的例子。 Run demo 1234567891011multiline('Hello World!'); // =&gt;` 'Hello Worl\nd!'multiline('Hello World!', &#123; width: 6 &#125;); // =&gt; 'Hello \nWorld!'multiline('Hello World!', &#123; width: 6, newLine: '*' &#125;); // =&gt; 'Hello *World!'multiline('Hello World!', &#123; width: 6, newLine: '*', indent: '_' &#125;); // =&gt; '_Hello *_World!' config 参数接受几套不同的属性值：你可以指定1，2或者3个属性值，甚至不指定任何一个属性。 使用对象扩展语法来填充配置对象非常简单，在对象字面量里，首先扩展默认值对象，然后是配置对象，如下所示： Run demo 12345678910111213141516function multiline(str, config = &#123;&#125;) &#123; const defaultConfig = &#123; width: 10, newLine: '\n', indent: '' &#125;; const safeConfig = &#123; ...defaultConfig, ...config &#125;; let result = ''; // Implementation of multiline() using // safeConfig.width, safeConfig.newLine, safeConfig.indent // ... return result;&#125; 我们来仔细了解一下 safeConfig 对象。 ...defaultConfig 首先将默认对象的属性复制，随后，...config 里用户自定义的值覆盖了之前的默认属性值。 这样 safeConfig 值就拥有了所有 multiline() 需要的配置参数。无论调用 multiline() 函数时，输入的 config 是否缺失了某些属性，都可以保证 safeConfig 拥有所有的必备参数。 显而易见，对象扩展实现了我们想要的 给对象设置默认值。 2.6 更加深入对象扩展更有用的一点是用于嵌套对象，当更新一个复杂对象时，更具有可读性，比 Object.assign() 更值得推荐。 下面的 box 对象定义一个盒子及盒子内的物品。 12345678const box = &#123; color: 'red', size: &#123; width: 200, height: 100 &#125;, items: ['pencil', 'notebook']&#125;; box.size 描述了这个盒子的尺寸，box.items 列举了盒子内的物品。 为了使盒子看起来更高，我们增大 box.size.height 的值，只需要在嵌套对象上使用 对象扩展符。 Run demo 123456789101112131415161718const biggerBox = &#123; ...box, size: &#123; ...box.size, height: 200 &#125;&#125;;console.log(biggerBox); /*&#123; color: 'red', size: &#123; width: 200, height: 200 &lt;----- Updated value &#125;, items: ['pencil', 'notebook']&#125;*/ ...box 确保了 biggerBox 获得了 源对象 box 上的全部属性。 更新 box.size 的 height 值需要额外一个 {...box.size, height: 200} 对象，该对象接收 box.size 的全部属性，并将 height 值更新至 200。 只需要一个语句就能更新对象的多处属性。 现在如果我们还想把颜色改成 black ,增加盒子的宽度到 400, 并且再放一把尺子到盒子内，应该怎么办？同样很简单。 Run demo 1234567891011121314151617181920212223const blackBox = &#123; ...box, color: 'black', size: &#123; ...box.size, width: 400 &#125;, items: [ ...box.items, 'ruler' ]&#125;;console.log(blackBox); /*&#123; color: 'black', &lt;----- Updated value size: &#123; width: 400, &lt;----- Updated value height: 100 &#125;, items: ['pencil', 'notebook', 'ruler'] `&lt;----- A new item ruler&#125;*/ 2.7 扩展 undefined、null 和 原始类型值如果在 undefined、null 和 原始类型值 上使用原始类型的值，不会复制任何属性，也不会抛出错误，只是简单的返回一个空对象。 Run demo 1234567const nothing = undefined; const missingObject = null; const two = 2;console.log(&#123; ...nothing &#125;); // =&gt; &#123; &#125; console.log(&#123; ...missingObject &#125;); // =&gt; &#123; &#125; console.log(&#123; ...two &#125;); // =&gt; &#123; &#125; 如上所示：从 nothing, missingObject 和 two不会复制任何属性。 当然，这只是一个演示，毕竟根本没有理由在一个原始类型的值上面使用对象扩展符。 3. 剩余属性当使用解构赋值将对象的属性值赋值给变量后，剩余的属性值将会被集合进一个剩余对象内。 下面的代码演示了怎么使用 rest 属性。 Run demo 12345678910const style = &#123; width: 300, marginLeft: 10, marginRight: 30&#125;;const &#123; width, ...margin &#125; = style;console.log(width); // =&gt; 300 console.log(margin); // =&gt; &#123; marginLeft: 10, marginRight: 30 &#125; 通过解构赋值，我们定义了一个新的变量 width ，并将它的值设置为 style.width。而解构赋值声明内的 ...margin 则获得了 style 对象的其余属性，margin 对象获取了 marginLeft 和 marginRight 属性。 rest 操作符同样只会获取自有属性和可枚举属性。 注意，在解构赋值内，rest 操作符只能放到最后，因此 const { ...margin , width } = style 无效，并会抛出一个 SyntaxError: Rest element must be last element 错误。 4. 结论对象扩展需要以下几点： 它只会提取对象的自有属性和可枚举属性 后定义的属性值会覆盖之前定义过的同名属性值 同时，对象扩展使用上方便简洁，能更好的处理嵌套对象，保持不可变性，在实现对象克隆和填充默认属性值上也使用方便。 而 rest 操作符在解构赋值时可以收集剩余的属性。]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之 Symbol]]></title>
    <url>%2Fposts%2F9ced4e66%2F</url>
    <content type="text"><![CDATA[Symbol 是 ES6 增加的第7种数据类型，也是第6种原始数据类型。symbol 值用来创建匿名的对象属性，同时也是唯一的，不会与其他属性名冲突。 创建一个 symbol 值Symbol 是一个函数，调用这个函数即创建了一个 symbol 值。 12typeof Symbol //functionvar sym = Symbol() 但是 Symbol 不是一个构造函数，使用 new 来创建，会抛出错误 1var sym = new Symbol() // TypeError: Symbol is not a constructor Symbol 函数可以接受一个参数，用于描述这个 symbol ，但是也仅仅是用于描述而已调用 toSring 方法可以读取到这个描述 12var sym1 = Symbol('hello world')console.log(sym1) // Symbol(hello world) 即使传入完全一样的描述，所创建的 symbol 也是不相同的 123var sym1 = Symbol('hello world')var sym2 = Symbol('hello world')console.log(sym1 === sym2) // false 使用 symbolsymbol 用于对象属性时，不能使用点字符，只能用于计算属性 123var obj = &#123;&#125;var sym = Symbol('hello world')obj[sym] = 'hello Symbol' 重复使用一个 symbol前面说过 每一个 symbol 值都是独一无二的，但是有时候我们也需要共用一个 symbol ，这时候就需要用到 Symbol.for 这一方法了。 Symbol.for 方法接受一个 key 参数，根据这个 key 在全局的 Symbol 注册值中查找，如果之前已经通过 Symbol.for 方法和该key 创建过，那么就返回这个已经创建的 symbol 值，否则以 key 值创建一个，并注册一个全局值。下面这个例子可以比较 Symbol 和 Symbol.for 的不同 1234567var sym1 = Symbol('hello world')var sym2 = Symbol('hello world')console.log(sym1 === sym2) // falsevar sym3 = Symbol.for('global')var sym4 = Symbol.for('global')console.log(sym3 === sym4) // true 当要创建 sym4 时，由于之前 已经用 global 这个值创建了 sym3 ，因此会直接把 sym3 的值赋给 sym4 和 Symbol.for 对应的另一个方法是 Symbol.keyForSymbol.keyFor 方法接受一个 symbol 值作为参数，返回对应的 key 值 1234// 接上例console.log(Symbol.keyFor(sym3)) // globalconsole.log(Symbol.keyFor(sym4)) // globalconsole.log(Symbol.keyFor(sym1)) // undefined 基本上，Symbol 了解这些就已经足够日常使用了。剩下的一些零零散散的知识和一些 Well-known Symbol 之后抽空看看。]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
