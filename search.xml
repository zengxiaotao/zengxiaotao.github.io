<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[compiler Compilation]]></title>
    <url>%2Fposts%2F82e413ee%2F</url>
    <content type="text"><![CDATA[目录 什么是 compiler 和 compilation compiler 启动过程 compilation 启动过程 compiler 和 compilation v先贴一张图，来自 webpack 官方的解释 原文链接 how to write a webpack plugin 简单翻译一下 compiler 对象代表了一个 webpack 完整的配置环境，在 webpack 启动时构建，包括了所有的可操作的配置项，比如 options , loaders 和 plugins。 compilation 对象则代表了一次 单次构建。每次文件变更的时候，都会开始一次新的编译。compilation 会提供以下信息：模块资源，已编译的文件，改变的文件，以及监听的依赖。 它们之间的关系是 options –&gt; Compiler -&gt; Compilation compiler 启动过程 源码地址 source 先上一个总览 生成一个 compiler 主要经历以下几个过程 开始编译 相关的生命周期钩子 beforeRun, run compile 相关的生命周期钩子 beforeCompile 、compile 和 make make 阶段，从入口点分析模块及其依赖的模块，创建这些模块对象 相关的生命周期钩子 make 这一步会根据 compiler 对象生成一个 compilation 对象，并且完成 compilation 的 finish, seal 过程 after-compilation 完成构建 记录编译信息 相关的生命周期钩子 shouldEmit, 编译文件 记录 records 先说说什么是 records “用于存储跨多次构建(across multiple builds)的模块标识符的数据片段”。可以使用此文件来跟踪在每次构建之间的模块变化。 如果你使用了代码分离(code splittnig)这样的复杂配置，records 会特别有用。这些数据用于确保拆分 bundle，以便实现你需要的缓存(caching)行为。 只需要配置 recordPath 即可开启 1recordsPath: path.join(__dirname, 'records.json') compiler 全部生命周期 beforeRun run beforeCompile compile make afterCompile shouldEmit / needAdditionalPass emit afterEmit done compilation 编译过程在 SingleEntryPlugin 里 调用addEntry执行 Compilation 的构造函数，只是生成了一个 compilation 的实例对象，包含了一系列编译信息。 但是又是在哪触发了编译过程？？？ 回到 compiler 里，在 compile 方法内，生成了 compilation 对象之后，紧接着会触发 compiler 的 make 钩子，按照之前讲的插件的写法，给生命周期注入钩子的写法，全局搜索 compiler.hooks.make.tap. 所以看到以下这7个插件，在compiler 的 make 生命周期注入了钩子。这里我们主要看 SingleEntryPlugin.js 这个文件。 因此，在 compiler 的 make 阶段触发了 compilation 模块的构建 addEntry在 addEntry 里并没有做太多操作，将传入的 entry 信息放入 _preparedEntrypoints 数组内，之后调用内部的 _addModuleChain 方法。 _addModuleChain在 _addModuleChain 内部会做两件事 根据传入的 dependency 找到对应的 ModuleFactory（模块工厂），调用模块工厂的 create 方法创建模块。 构建模块 创建模块什么是 ModuleFactory（模块工厂）回想一下，在写一个 webpack.config.js 时，是怎么写 entry 的。最常用的是一个字符串比如 ./src/index.js。但是 entry 也支持数组，对象，函数等写法, 不同的写法对应的 模块工厂 如下 string –&gt; normalModuleFactory array –&gt; MultiModuleFactory function -&gt; normalModuleFactory &amp;&amp; MultiModuleFactory 因此也分别对应 SingleEntryPlugin、MultiEntryPlugin 和 DynamicEntryPlugin webpack entry doc 对于不同的 entry ，webpack 是如何选择不同的 ModuleFactory 。 在 ./EntryOptionPlugin 内 buildModule这一步主要在 this.buildModule 内。 这里将会调用 module.build 来构建模块，module 即是不同的 moduleFactory 通过 create 方法生成的。这里已 normalModule 为例。 normalModule.build 方法会调用 this.doBuild 来创建模块。 doBuilddoBuild 是个重要的方法。loaders 主要在这里起作用。会生成一个 this._source 和 this._ast, 之后 this.parser.parse() 生成真正的 ast。 全局搜索 Parser( 处理依赖关系 processModuleDependencies一个 module 可能会依赖其他的许多模块，因此每一个模块都会有一个 dependencies 数组。模块构建完成后，就要开始处理模块与模块间的依赖关系了。 那么 webpack 如何识别并收集这些依赖关系的。 同样是通过各种插件来实现的 全局搜索 DependencyParserPlugin 试试。 给处理好的依赖关系添加模块 addModuleDependencies这里我的理解是 对于一个 module ，当它的 dependencies 处理好之后，应该对 dependencies 开始构建模块，所有也会依次调用 build, dobuild 等方法来构建模块，同样也可以对 子模块 调用 processModuleDependencies。这样循环下去，也就形成了一个 依赖树。 finish至此, addEntry 和 _addModuleEntry 方法就执行完毕。 回到 compiler 文件。剩下的是 finish 和 seal() 方法。 胜利就在前方。 finish 方法很简单，执行一下 finishModules 生命周期的钩子和检查一下模块是否有错误等等。 sealseal 方法是一个很重要的方法。也是优化应该重点关注的一个地方。在这里，模块依赖树已经生成完成。seal 方法里会触发大量的生命周期钩子，不乏一些 optimize* 等钩子。同样这里也会生成 hash 等信息，对 module 进行排序等。 最重要的会触发 createChunkAssets 方法。同时也进入了 compilation 一个新的阶段: 打包输出。 打包输出createChunkAssets首先介绍一下 template 的概念。 通过 webpack 打包生成的文件，很明显会有很多 template 信息。比如 __webpack_require__ ，这些 字符串又是怎么生成的，不同的场景下生成的这些字符串又有何不同，这里就涉及到了模板的概念。 在 webpack/lib 下执行 find **Template.js 会看到几个 template 文件。它们决定了应该怎么生成最终的打包文件文本。 createChunkAssets 的作用是根据 compilation 的 chunks ，分析其中每一个 chunk 所包含的文件(files)，根据每一个 file 生成 file 的 content string 也就是 source, 将这些 source 统一放入 this.assets 对象内。 但注意的是，这里还没有写入文件。只是生成了一段文本。真正生成文件的工作，前面说过，会在 compiler 的 emitAssets 方法内。 生成 assets 之后，进入到 chunkAsset 生命周期，如果你想对 source 做任何更改，这里是最佳时期。 Q&amp;&amp;A 不同plugin的执行顺序 参考链接：https://stackoverflow.com/questions/41470771/webpack-does-the-order-of-plugins-matter 可以看到根据 for (plugin of options.plugins) 的顺序注册 plugin。 因此，个人理解 plugin 的执行属性决定于 在 options.plugins 书写的顺序 注册后，执行的顺序，这里会涉及到 tapable 的相关知识。 plugin 注册的生命周期，举个栗子，pluginA 在 compiler 的 beforeRun 起作用，pluginB 在 run 上起作用，无论书写顺序如何，都应该是 pluginA先起作用。 优化 (1) https://medium.com/@songawee/long-term-caching-using-webpack-records-9ed9737d96f2演示 records 的 demo (2) 设置 babel-loader?cacheDirectory=true (3) webpack-parallel-uglify-plugin next 新的 bach 工程怎么做的 cat package.json | grep &quot;start&quot; 可以看到是执行了 ./webpack/server.js server.js 起了一个 express 服务器，使用了 webpack-dev-middleware 生成一个中间件，来监听文件的变化。 tapable]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack源码解析(for webpack v4)]]></title>
    <url>%2Fposts%2Fd5545be8%2F</url>
    <content type="text"><![CDATA[目录 webpack-cli 工具介绍 webpack node api webpack 启动过程 如何自己写一个 webpack plugin 如何自己写一个 webpack loader webpack-cli什么是 webpack-cli webpack CLI is a CLI tool for providing a flexible set of commands for developers to increase speed when setting up a custom webpack project. As of webpack v4, webpack is not expecting a configuration file but often, developers want to create a more custom webpack configuration based on their use-cases and needs. Exactly all these cases with webpack CLI we are providing a set of tools to improve the setup of custom webpack configuration. 随着 webpack 4.0.0 推出，webpack 将命令行的代码迁移到 webpack-cli。 Webpack-cli 提供了一系列的工具来增强 webpack 的可配置性。 安装安装 webpack 4.0.0 之后的版本，webpack-cli 不会随着 webpack 一起安装，当运行 npx webpack 之后，会提示安装 webpack-cli 或者 webpack-command 。但 webpack-command 已经不推荐安装使用。。 常用命令webpack-cli 提供了很多常用的命令，包括 init, add, info, migarate, remove, generate-loader, generate-plugin, serve, update。 使用每种命令之前，都需要对命令单独安装，npm install @webpack-cli/&lt;command&gt;。分别介绍一下。 init init 命令将会初始化一个 webpack 工程，将会在当前目录下新建一个 webpack.prod.js 文件, 包括一些常用的配置。 add add 命令会询问一系列的问题，之后会在配置文件添加相关的属性，而不用自己手工配置。 info 运行 info 命令，将会输出一系列的系统信息。包括 webpack, webpack-cli, node, npm 和浏览器的版本信息。 migarate 将你的 webpack 工程迁移到具体的webpack 上，会根据不同版本的 webpack 支持的特性，更改相对应的 webpack 配置。 remove 和 add 添加属性相反，remove 命令是移除对应的配置项。 generate-loader 如果想要自己写一个 webpack loader, 该命令会帮你生成一个 webpack loader 的工程目录。 generate-plugin 同理，会生成一个 webpack plugin 的工程目录。 serve 会启动一个 webpack-serve 服务。 update 该命令会将当前的 webpack 配置文件升级到新的版本，你可以选择要升级的 webpack 配置项。 webpack node api虽然通过 webpack 配置文件可以打包资源，通过各种 plugin 和 loader 可以满足我们大部分需要，但是 webpack node api 能帮助我们实现对配置选项更加精度的控制，通过 node api 生成的 compiler 对象,对其处理，能实现更高级别的功能。比如根据配置对象开启一个 node 服务。常见的比如 webpack-dev-server 就是通过这种方式。 webpack-dev-serve/bin/webpack-dev-server.js compiler1const webpack = require('webpack'); webpack 函数会接收 2 个参数，第一个参数就是传入的 options 配置对象，第二个参数为一个 callback 函数。只传入配置对象时，将会生成一个 compiler 对象。如果传入了 callback , 则会自动执行 compiler.run 方法 1const compiler = webpack(options, [callback]); compiler 会暴露出 run 和 watch 方法。run 方法会立即编译打包文件。watch 方法也会打包文件，但会自动监听文件变化，从而重新打包。 run1compiler.run(function(err,stats) &#123;&#125;); watch1compiler.watch(watchOptions, function(err, stats)&#123;&#125;); webpack 启动过程 (源码部分) 输入 webpack 到底做了什么 输入 webpack 会报错 command not found: webpack正确的做法是 npx webpack webpack 4.0 之后，随之推出的还有 webpack-cli。 如果只安装了 webpack 而没有安装 webpack-cli，启动 webpack 的时候，会提醒你安装 webpack-cli 。 具体逻辑在 webpack/cli/webpack.js 内 成功安装 webpack-cli后，再次输入 npx webpack 之后, webpack-cli 将负责启动的逻辑。 webpack-cliwebpack-cli/bin/cli.js。 在命令行输入 npx webpack 后，cli.js 会判断是编译相关的命令还是功能性命令。 如果是非编译命令，会调用 ./prompt-command.js 安装或执行对应的模块。 webpack-cli/bin/prompt-command.js 完成这些工作后，就会开始解析输入的 webpack 相关参数，开始编译文件(webpack-cli/bin/cli-js line48)。 之后是定义的一些 option 信息，可以通过 npx webpack -h 查看 稍稍说一下 yargs Yargs helps you build interactive command line tools, by parsing arguments and generating an elegant user interface. yargs 同 commander 类似，都是 构建 cli 工具，目前在 npm 上的周下载量已经超过了 commander 。 yargs.parse 方法。 .parse 方法负责解析在命令行传入的 webpack 编译选项，方法接收 3 个参数，分别是传入的 argv, context, 以及解析完成后的 callback。 callback 方法同样接收 3 个参数，err, argv 表示解析的 argv 对象，以及在命令行输出的 output。 举个栗子。 当输入的选项为 npx webpack --config webpack.config.js --silence。解析完成后，callback 拿到的 argv 对象如下: 1234567891011&#123; _: [], cache: null, bail: null, profile: null, color: [Function: getSupportLevel], colors: [Function: getSupportLevel], config: 'webpack.config.js', // silence: true, // 'info-verbosity': 'info', infoVerbosity: 'info', '$0': 'node_modules/.bin/webpack' &#125; 编译从 249 行开始，就开始正式处理传入的编译选项。 首先还是惯例的错误处理。之后通过 ifArg 方法，将传入的 argv 转化成 webpack 可用的 option, 生成 compiler 对象，之后判断是否传入了 watch 选项，从而决定是执行 compiler 的 run 方法还是 watch 方法。 总结一下输入 npx webpack 后到底会发生什么？ webpack/bin/cli.js 会检查是否安装了 webpack-cli。(一般是 webpack-cli ，其实也可以是 webpack-command)。 如果安装了 webpack-cli ，调用对应的 bin 文件。否则安装 webpack-cli。 wepack-cli/bin/cli.js 会解析传入的命令行参数。如果不是编译相关的参数，会安装对应的功能模块。如果是确实要进行编译，调用 webpack 生成 compiler 对象，之后通过 run 或者 watch 方法生成编译文件。 webpackwebpack/lib/webpack.js 传入 option 进行错误检查之后，如果是个数组，会调用 Multicompiler ，如果只是个普通对象，也就是我们最常用的那种，调用 compiler 生成 compiler 对象。 设置默认 option 对象 webpack v4 之前，webpack 最少只需要 entry 和 output 两个配置项即可。当零配置构建工具 Parcel 推出后，webpack v4 把这两个配置项也取消了，也实现了零配置。但是你的项目下必须要有 src/index.js 。所以，这些是如何完成的？ webpack/lib/WebpackOptionsDefaulter.js 映入眼帘的是 1class WebpackOptionsDefaulter extends OptionsDefaulter &#123;&#125; 所以看看 webpack/lib/OptionsDefaulter.js。 OptionDefaulter 上实现了 set 方法和 process 方法供 WebpackOptionDefault 使用。 在 WebpackOptionDefaulter 的构造函数里即完成了所有默认选项的配置。 对生成的 compiler 应用 plugins 根据 callback 以及 watch 选项来决定，执行 compiler 的 watch 方法或者 run 方法。 在 webpack 上挂载内部插件。 如何自己写一个 webpack plugin参考链接 一个 webpack plugin 本质上是一个是一个构造函数，生成的 plugin 实例继承原型上的 apply 方法。 123456function SimplestPlugin(options) &#123; // 插件的配置对象&#125;SimplestPlugin.prototype.apply = function(compiler) &#123; console.log('this is a webpack plugin');&#125; 以上就是一个最简单的一个 plugin。使用方式同平常的插件一样 123456789const SimplestPlugin = require('pathToYourPlugin');module.exports = &#123; ... plugins: [ ... new SimplestPlugin() ]&#125; apply 方法接收webpack 生成的 compiler 作为参数, 我们可以在插件内部对 complier 进行处理，或者在不同阶段触发钩子函数。 compiler 钩子Compiler 继承自 Tapable 。Tapable 是 webpack 内部自己实现的一个用于事件发布订阅执行的插件架构。这里先不介绍了。 compiler 对象会暴露出 webpack 不同生命周期钩子函数 具体的可以在文档中查到 具体的触发方式, 比如在 emit 和 done 两个生命周期触发。 12compiler.hooks.emit.tap('SimplestPlugin', (params) =&gt; &#123;&#125;)compiler.hooks.done.tap('SimplestPlugin', (params) =&gt; &#123;&#125;) 要注意的是，在不同的生命周期阶段内，传入回调函数的 params 并不是一成不变的。 比如 12345SimplestPlugin.prototype.apply = function(compiler) &#123; compiler.hooks.emit.tap('SimplestPlugin', (params) =&gt; &#123; console.log(params.contructor); &#125;)&#125; 可以看到，在 emit 阶段传给回调函数的是 Compilation 的实例 12345SimplestPlugin.prototype.apply = function(compiler) &#123; compiler.hooks.done.tap('SimplestPlugin', (params) =&gt; &#123; console.log(params.contructor); &#125;)&#125; 而在 done 阶段，传给回调函数的参数变成了 Stats 的实例。 其他写法这种写法目前已经废弃，但是在网上的一些教程里还是能经常看到。 12345SimplestPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('done', (params) =&gt; &#123; console.log(params.contructor); &#125;)&#125; 这种方法仍然能够使用，但是会提示废弃信息，所以建议以第一种方式为主。 compilation 钩子compilation 钩子的使用方法和 compiler 钩子的使用方法一样。在 compilation 的生命周期的不同阶段，可以对 compilation 进行处理。 compilation 的生命周期钩子可以看这 一个稍微复杂点的例子12345678910111213141516function SimplestPlugin(options) &#123; // 插件的配置对象 this._options = this.options; this.filename = options.filename;&#125;SimplestPlugin.prototype.apply = function(compiler) &#123; let filename; let filepath; compiler.hooks.emit.tap('SimplestPlugin', compilation =&gt; &#123; filename = this.filename || compilation.hash; filepath = `$&#123;filename&#125;.json` &#125;) compiler.hooks.done.tap('SimplestPlugin', stats =&gt; &#123; fs.writeFileSync(filepath, JSON.stringify(stats.compilation.options)) &#125;)&#125; 运行该插件后，每次编译完成都会将本次编译的 webpack 配置保存到文件中, 文件名为本次编译的 hash 值。 compilation 对象每个 compilation 对象代表一次编译，可以从里面获得本次编译的一些有用信息。 compliation.modules: 每一个资源文件都会编译成一个模块，每一个 module 会有一个 fileDependencies 属性，记录了这个模块的所有依赖项。 compilation.chunks: 是entry的每个配置项及调用require.ensure的模块，每个chunk的， chunk.modules为chunk包含的模块以及模块所依赖的模块， chunk.files为每个配置项最后的输出结果文件. compilation.assets: 整个打包流程最终要输出的文件, 通过 compilation.assets[filename].source()可以获取到每个生成的的文件的内容。 如何写一个 webpack loader相比于写一个 webpack plugin ，写一个 webpack 的 loader 就相对简单得多 基本构成参考链接 一个 webpack loader 本质上就是一个函数，函数接收3个参数，分别是 文件内容的 content, 文件的 sourceMap, 以及一个 meta。 一个最基本的例子最近做的需求很多时候会和 csv 文件打交道，例如 csv 的解析和生成。如果可以交给 loader 来做，应该是这样 假设这里有一个 csv 文件 123a,b,c1,2,32,4,6 假设需要统计出每一个 csv 文件的长度。 在 node_modules 文件夹内(假设还未发布到 npm), 新建一个 test-csv-loader 文件夹，文件夹内只需要一个 index.js。 123456module.exports = function countCsvLength(content) &#123; console.log(content); const length = content.length; return `module.exports=function() &#123;return $&#123;length&#125;&#125;`&#125; 一个 loader 就完成了，之后在配置文件中引用。 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /.csv$/', loader: 'test-csv-loader', &#125; ] &#125;&#125; 执行 npx webpack, 打包成功了。 在生成的 dist/main.js 中可以看到这一段。 项目的 src/index.js 内容如下： 1234console.log('hello world');const a = require('../a.csv');console.log(a()); 执行 dist/main.js，得到了预想中的结果。 以上。 对 content 进行处理基本上能解决平时遇到的小需求。更高级的用法可以看文档深究。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】对象扩展符简易指南]]></title>
    <url>%2Fposts%2Fadc6686%2F</url>
    <content type="text"><![CDATA[合并多个 Javascript 对象是常见的工作，但不好的是，至少到目前，Javascript 仍然没有一种方便的方法来完成这个工作。至少现在是这样。 在 ES5 时代，你可以使用 Lodash 的 _.extend(target, [sources]) 方法，而 ES2015 则引入了 Object.assign(target, [sources]) 方法。 幸运的是，对象扩展符 (an ECMASript proposal at stage 3) 是一个很大的进步，提供了简单方便的如下简介方便的语法。 Run demo 12345678910const cat = &#123; legs: 4, sound: 'meow'&#125;;const dog = &#123; ...cat, sound: 'woof'&#125;;console.log(dog); // =&gt; &#123; legs: 4, sounds: 'woof' &#125; 上面的例子中，...cat 复制 cat 的属性到一个新对象 dog 中，cat 中原来的属性 sound 被覆盖，最终值为 woof。 本篇文章将介绍对象 spread 和 rest 语法。包括如何实现对象克隆，对象合并，以及如何覆盖属性值。 下面是关于可枚举属性的简单和概括，以及如何分辨对象自有属性和继承属性。 1. 可枚举以及自有属性Javascript 里的对象是键值对的组合。 键名通常是一个字符串或者一个 symbol 。值可以是一个原始类型的值(string, boolean, number, undefined 或者 null)，一个对象或者一个函数。 下面这个例子将通过对象字面量语法创建一个对象。 1234const person = &#123; name: 'Dave', surname: 'Bowman'&#125;; person 这个对象描述了一个人的名和姓氏。 1.1 可枚举属性描述一个属性有几种描述符，如 writable、enumerable 和configurable 。你可以看这篇文章Object properties in JavaScript了解更多细节。 Enumerable 描述符是一个布尔值，表示这个属性是否可以被枚举。 你可以通过 Object.keys() 方法来枚举一个对象的自有属性和可枚举属性，通过 for..in 语句来枚举所有可枚举的属性。 以对象字面量的形式创建对象 { prop1: &#39;val1&#39;, prop2: &#39;val2&#39; } 时显式声明的属性都是可枚举的。接下来看看之前创建的 person 对象有哪些可枚举的属性。 Run demo 12const keys = Object.keys(person); console.log(keys); // =&gt; ['name', 'surname'] .name 和 .surname 是 person 对象的可枚举属性 接下来是有趣的一部分。对象扩展符复制了原对象的所有可枚举属性。 Run demo 1console.log(&#123; ...person &#125;; // =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125; 下面我们在 person 对象上创建一个不可枚举属性 .age。 Run demo 12345678910Object.defineProperty(person, 'age', &#123; enumerable: false, // Make the property non-enumerable value: 25&#125;);console.log(person['age']); // =&gt; 25const clone = &#123; ...person&#125;;console.log(clone); // =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125; 目标对象 clone 从源对象 person 上创建了可枚举属性 .name 和 .surname ，但是不可枚举属性 .age 则被忽略掉。 1.2 自有属性Javascript 内有原型继承机制，因此一个对象上既有 自有属性，也有从继承属性。 对象字面量显式声明的属性都是自有属性，存在于原型链上的属性都是 继承 属性。 下面将创建一个 personB 对象，并将 person 对象设置成其原型对象。 Run demo 12345678910const personB = Object.create(person, &#123; profession: &#123; value: 'Astronaut', enumerable: true &#125;&#125;);console.log(personB.hasOwnProperty('profession')); // =&gt; true console.log(personB.hasOwnProperty('name')); // =&gt; false console.log(personB.hasOwnProperty('surname')); // =&gt; false 现在 personB 上有自有的 .profession 属性，以及从原型对象 person 上继承来的 .name 和 .surname 属性。 对象扩展符从源对象上复制自有属性，而会忽略继承的属性 Run demo 1234const cloneB = &#123; ...personB&#125;;console.log(cloneB); // =&gt; &#123; profession: 'Astronaut' &#125; ...personB 只从 personB 上复制了 .profession 这个自有属性，而继承属性 .name 和 .surname 则被忽略。 总结： 对象扩展符号只会从源对象上复制 自有和可枚举属性，这和 Object.keys() 方法的返回值一样。 2. 对象扩展属性在对象字面量里，对象扩展符将源对象里的自有属性和可枚举属性复制进目标对象内。 1234const targetObject = &#123; ...sourceObject, property: 'Value'&#125;; 顺便说一下，很多时候，对象扩展符与 Object.assign() 等价，上面的代码也可以用这样实现： 12345const targetObject = Object.assign( &#123; &#125;, sourceObject, &#123; property: 'Value' &#125;); 一个对象字面量里可以使用多个对象扩展符，与普通的属性声明同时使用： 1234567const targetObject = &#123; ...sourceObject1, property1: 'Value 1', ...sourceObject2, ...sourceObject3, property2: 'Value 2'&#125;; 2.1 对象扩展规则：后面的属性会覆盖前面的当同时扩展多个对象时，这个对象内可能会存在同名属性，那么最终生成的对象的属性值是怎么计算的，规则很简单：后扩展的属性会覆盖之前扩展的属性。 来看一些简单的例子。下面的代码会实例化一只 cat 。 1234const cat = &#123; sound: 'meow', legs: 4&#125;; 现在我们要变一个魔术，将这只猫变成一只狗，注意 .sound 属性值如何变化。 Run demo 1234567const dog = &#123; ...cat, ...&#123; sound: 'woof' // `&lt;----- Overwrites cat.sound &#125;&#125;;console.log(dog); // =&gt;` &#123; sound: 'woof', legs: 4 &#125; 后面声明的 ·woof· 属性值覆盖了前面的在 cat 对象声明的属性值 &#39;meow&#39; , 符合之前所说的规则: 对于同名属性，后声明的值覆盖先声明的值。 这个规则同样适用于对象的初始化 Run demo 12345const anotherDog = &#123; ...cat, sound: 'woof' // `&lt;---- Overwrites cat.sound&#125;;console.log(anotherDog); // =&gt;` &#123; sound: 'woof', legs: 4 &#125; 上面代码里，sound: &#39;woof&#39; 同样覆盖了之前声明的 &#39; meow&#39; 值。 现在，交换一下扩展对象的位置，输出了不同的结果。 Run demo 1234567const stillCat = &#123; ...&#123; sound: 'woof' // `&lt;---- Is overwritten by cat.sound &#125;, ...cat&#125;;console.log(stillCat); // =&gt;` &#123; sound: 'meow', legs: 4 &#125; cat 对象仍然是 cat 对象。虽然第一个源对象内的 .sound 属性值是 &#39;woof&#39; ，但是被之后 cat 对象的 &#39;meow&#39; 覆盖。 普通属性和对象扩展的相对位置非常重要，这将直接影响到对象克隆，对象合并，以及填充默认属性的结果。 下面分别详细介绍。 2.2 克隆对象用对象扩展符克隆一个对象非常简洁，下面的代码克隆了一个 bird 对象。 Run demo 1234567891011const bird = &#123; type: 'pigeon', color: 'white'&#125;;const birdClone = &#123; ...bird&#125;;console.log(birdClone); // =&gt; &#123; type: 'pigeon', color: 'white' &#125; console.log(bird === birdClone); // =&gt; false ...bird 将 bird 对象的自有和可枚举属性复制到目标对象 birdClone 内。 虽然克隆看起来很简单，但仍然要注意其中的几个细微之处。 浅复制对象扩展只是对对象进行了 浅复制, 只有对象自身被复制，而嵌套的对象结构 没有被复制。 laptop 对象有一个嵌套对象 laptop.screen。现在我们来克隆 laptop对象来看看其内部的嵌套对象怎么变化。 Run demo 12345678910111213const laptop = &#123; name: 'MacBook Pro', screen: &#123; size: 17, isRetina: true &#125;&#125;;const laptopClone = &#123; ...laptop&#125;;console.log(laptop === laptopClone); // =&gt; false console.log(laptop.screen === laptopClone.screen); // =&gt; true 第一个比较语句 laptop === laptopClone 的值为 false, 说明主对象被正确克隆。 然而 laptop.screen === laptopClone.screen 的计算结果为 true ，说明 laptopClone.screen 没有被复制，而是 laptop.screen 和 laptopClone.screen 引用了同一个嵌套对象。 好的一点是，你可以在对象的任何一层使用对象扩展符，只需要再多做一点工作就同样可以克隆一个嵌套对象。 Run demo 123456789const laptopDeepClone = &#123; ...laptop, screen: &#123; ...laptop.screen &#125;&#125;;console.log(laptop === laptopDeepClone); // =&gt; false console.log(laptop.screen === laptopDeepClone.screen); // =&gt; false 使用 ...laptop.screen 使嵌套对象也被克隆，现在 laptopDeepClone 完全克隆了 laptop。 原型失去了下面的代码声明了一个 Game 类，并创造了一个 doom实例。 Run demo 1234567891011121314class Game &#123; constructor(name) &#123; this.name = name; &#125; getMessage() &#123; return `I like $&#123;this.name&#125;!`; &#125;&#125;const doom = new Game('Doom'); console.log(doom instanceof Game); // =&gt; true console.log(doom.name); // =&gt; "Doom" console.log(doom.getMessage()); // =&gt; "I like Doom!" 现在我们克隆一个通过构造函数创建的 doom 实例，结果可能与你想的不同。 Run demo 12345678const doomClone = &#123; ...doom&#125;;console.log(doomClone instanceof Game); // =&gt; false console.log(doomClone.name); // =&gt; "Doom" console.log(doomClone.getMessage()); // TypeError: doomClone.getMessage is not a function ...doom 将自有属性 .name 属性复制到 doomClone 内。 doomClone 现在只是一个普通的 JavaScript 对象，它的原型是 Object.prototype 而不是预想中的Game.prototype。对象扩展不保留源对象的原型。 因此调用 doomClone.getMessage() 方法会抛出一个 TypeError 错误，因此 doomClone 没有继承 getMessage() 方法。 当然我们可以手动在克隆对象上加上 __proto__ 属性来结局这个问题。 Run demo 12345678const doomFullClone = &#123; ...doom, __proto__: Game.prototype&#125;;console.log(doomFullClone instanceof Game); // =&gt; true console.log(doomFullClone.name); // =&gt; "Doom" console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 对象字面量内部的 __proto__ 属性确保了 doomFullClone 的原型为 Game.prototype。 尽量不要尝试这种方法。__proto__ 属性已经废弃，这里使用它只是为了论证前面的观点。 对象扩展的目的是以浅复制的方式扩展自有和可枚举属性，因此不保留源对象的原型似乎也说得过去。 例外，这里用 Object.assign() 来克隆 doom 更加合理。 Run demo 12345const doomFullClone = Object.assign(new Game(), doom);console.log(doomFullClone instanceof Game); // =&gt; true console.log(doomFullClone.name); // =&gt; "Doom" console.log(doomFullClone.getMessage()); // =&gt; "I like Doom!" 这样，就保留了原型。 2.3 不可变对象更新在一个应用里，同一个对象可能会用于多个地方，直接修改这个对象会带来意想不到的副作用，并且追踪这个修改及其困难。 一个好的方式是使操作不可变。不可变性使修改对象更为可控，更有利于书写。pure functions。即时是在复杂的应用场景，由于单向数据流，更容易确定对象的来源和改变的原因。 使用对象扩展能更方便的以不可变方式来修改一个对象。假设现在你有一个对象来描述一本书的信息。 123456const book = &#123; name: 'JavaScript: The Definitive Guide', author: 'David Flanagan', edition: 5, year: 2008&#125;; 现在，书第六版即将出版，我们用对象扩展的处理这个场景。 Run demo 123456789101112131415const newerBook = &#123; ...book, edition: 6, // &lt;----- Overwrites book.edition year: 2011 // &lt;----- Overwrites book.year&#125;;console.log(newerBook); /*&#123; name: 'JavaScript: The Definitive Guide', author: 'David Flanagan', edition: 6, year: 2011&#125;*/ newerBook 对象内的 ...book 扩展了 book 对象的属性。手动创建的可枚举属性 editon: 6 和 year: 2011 更新了原有的同名属性。 重要的属性一般在末尾来指定，以便覆盖前面已经创建的同名属性。 newerBook 是一个更新了某些属性的新的对象，并且我们没有改变原有的 book 对象，满足了不可变性的要求。 2.4 合并对象使用对象扩展符合并多个对象非常简单。 现在我们合并3个对象来创建一个“合成对象”。 Run demo 12345678910111213141516const part1 = &#123; color: 'white'&#125;;const part2 = &#123; model: 'Honda'&#125;;const part3 = &#123; year: 2005&#125;;const car = &#123; ...part1, ...part2, ...part3&#125;;console.log(car); // &#123; color: 'white', model: 'Honda', year: 2005 &#125; 上面的例子中，我们使用 part1、part2、part3 3个对象合并成了一个 car 对象。 另外，不要忘了之前讲的规则，后面的属性值会覆盖前面的同名属性值。这是我们合并有同名属性对象的计算依据。 现在我们稍微改变一下之前的代码。给 part1 和 part3 增加一个 .configuration 属性。 Run demo 1234567891011121314151617181920212223242526const part1 = &#123; color: 'white', configuration: 'sedan'&#125;;const part2 = &#123; model: 'Honda'&#125;;const part3 = &#123; year: 2005, configuration: 'hatchback'&#125;;const car = &#123; ...part1, ...part2, ...part3 // &lt;--- part3.configuration overwrites part1.configuration&#125;;console.log(car); /*&#123; color: 'white', model: 'Honda', year: 2005, configuration: 'hatchback' `&lt;--- part3.configuration&#125;*/ ...part1 将 configuration 属性设置成了 &#39;sedan&#39;。然而之后的扩展符 ...part3 覆盖了之前的同名 .configuration，最终生成的对象值为 &#39;hatchback&#39;。 2.5 给对象设置默认值一个对象在程序运行时可能会有多套不同的属性值，有些属性可能会被设置，有些则可能被忽略。 这种情况通常发生在一个配置对象上。用户可以指定一个重要的属性值，不重要的属性则使用默认值。 现在我们来实现一个 multline(str, config) 方法，将str 按照给定的长度分割成多行。 config 对象接受下面3个可选的参数。 width: 分割的字符长度，默认是 10。 newLine: 添加到每一行结尾的的字符， 默认是 \n。 indent: 每一行开头的缩进符，默认是空字符串 &#39;&#39;。 下面是一些 multline() 运行的例子。 Run demo 1234567891011multiline('Hello World!'); // =&gt;` 'Hello Worl\nd!'multiline('Hello World!', &#123; width: 6 &#125;); // =&gt; 'Hello \nWorld!'multiline('Hello World!', &#123; width: 6, newLine: '*' &#125;); // =&gt; 'Hello *World!'multiline('Hello World!', &#123; width: 6, newLine: '*', indent: '_' &#125;); // =&gt; '_Hello *_World!' config 参数接受几套不同的属性值：你可以指定1，2或者3个属性值，甚至不指定任何一个属性。 使用对象扩展语法来填充配置对象非常简单，在对象字面量里，首先扩展默认值对象，然后是配置对象，如下所示： Run demo 12345678910111213141516function multiline(str, config = &#123;&#125;) &#123; const defaultConfig = &#123; width: 10, newLine: '\n', indent: '' &#125;; const safeConfig = &#123; ...defaultConfig, ...config &#125;; let result = ''; // Implementation of multiline() using // safeConfig.width, safeConfig.newLine, safeConfig.indent // ... return result;&#125; 我们来仔细了解一下 safeConfig 对象。 ...defaultConfig 首先将默认对象的属性复制，随后，...config 里用户自定义的值覆盖了之前的默认属性值。 这样 safeConfig 值就拥有了所有 multiline() 需要的配置参数。无论调用 multiline() 函数时，输入的 config 是否缺失了某些属性，都可以保证 safeConfig 拥有所有的必备参数。 显而易见，对象扩展实现了我们想要的 给对象设置默认值。 2.6 更加深入对象扩展更有用的一点是用于嵌套对象，当更新一个复杂对象时，更具有可读性，比 Object.assign() 更值得推荐。 下面的 box 对象定义一个盒子及盒子内的物品。 12345678const box = &#123; color: 'red', size: &#123; width: 200, height: 100 &#125;, items: ['pencil', 'notebook']&#125;; box.size 描述了这个盒子的尺寸，box.items 列举了盒子内的物品。 为了使盒子看起来更高，我们增大 box.size.height 的值，只需要在嵌套对象上使用 对象扩展符。 Run demo 123456789101112131415161718const biggerBox = &#123; ...box, size: &#123; ...box.size, height: 200 &#125;&#125;;console.log(biggerBox); /*&#123; color: 'red', size: &#123; width: 200, height: 200 &lt;----- Updated value &#125;, items: ['pencil', 'notebook']&#125;*/ ...box 确保了 biggerBox 获得了 源对象 box 上的全部属性。 更新 box.size 的 height 值需要额外一个 {...box.size, height: 200} 对象，该对象接收 box.size 的全部属性，并将 height 值更新至 200。 只需要一个语句就能更新对象的多处属性。 现在如果我们还想把颜色改成 black ,增加盒子的宽度到 400, 并且再放一把尺子到盒子内，应该怎么办？同样很简单。 Run demo 1234567891011121314151617181920212223const blackBox = &#123; ...box, color: 'black', size: &#123; ...box.size, width: 400 &#125;, items: [ ...box.items, 'ruler' ]&#125;;console.log(blackBox); /*&#123; color: 'black', &lt;----- Updated value size: &#123; width: 400, &lt;----- Updated value height: 100 &#125;, items: ['pencil', 'notebook', 'ruler'] `&lt;----- A new item ruler&#125;*/ 2.7 扩展 undefined、null 和 原始类型值如果在 undefined、null 和 原始类型值 上使用原始类型的值，不会复制任何属性，也不会抛出错误，只是简单的返回一个空对象。 Run demo 1234567const nothing = undefined; const missingObject = null; const two = 2;console.log(&#123; ...nothing &#125;); // =&gt; &#123; &#125; console.log(&#123; ...missingObject &#125;); // =&gt; &#123; &#125; console.log(&#123; ...two &#125;); // =&gt; &#123; &#125; 如上所示：从 nothing, missingObject 和 two不会复制任何属性。 当然，这只是一个演示，毕竟根本没有理由在一个原始类型的值上面使用对象扩展符。 3. 剩余属性当使用解构赋值将对象的属性值赋值给变量后，剩余的属性值将会被集合进一个剩余对象内。 下面的代码演示了怎么使用 rest 属性。 Run demo 12345678910const style = &#123; width: 300, marginLeft: 10, marginRight: 30&#125;;const &#123; width, ...margin &#125; = style;console.log(width); // =&gt; 300 console.log(margin); // =&gt; &#123; marginLeft: 10, marginRight: 30 &#125; 通过解构赋值，我们定义了一个新的变量 width ，并将它的值设置为 style.width。而解构赋值声明内的 ...margin 则获得了 style 对象的其余属性，margin 对象获取了 marginLeft 和 marginRight 属性。 rest 操作符同样只会获取自有属性和可枚举属性。 注意，在解构赋值内，rest 操作符只能放到最后，因此 const { ...margin , width } = style 无效，并会抛出一个 SyntaxError: Rest element must be last element 错误。 4. 结论对象扩展需要以下几点： 它只会提取对象的自有属性和可枚举属性 后定义的属性值会覆盖之前定义过的同名属性值 同时，对象扩展使用上方便简洁，能更好的处理嵌套对象，保持不可变性，在实现对象克隆和填充默认属性值上也使用方便。 而 rest 操作符在解构赋值时可以收集剩余的属性。]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之 Symbol]]></title>
    <url>%2Fposts%2F9ced4e66%2F</url>
    <content type="text"><![CDATA[Symbol 是 ES6 增加的第7种数据类型，也是第6种原始数据类型。symbol 值用来创建匿名的对象属性，同时也是唯一的，不会与其他属性名冲突。 创建一个 symbol 值Symbol 是一个函数，调用这个函数即创建了一个 symbol 值。 12typeof Symbol //functionvar sym = Symbol() 但是 Symbol 不是一个构造函数，使用 new 来创建，会抛出错误 1var sym = new Symbol() // TypeError: Symbol is not a constructor Symbol 函数可以接受一个参数，用于描述这个 symbol ，但是也仅仅是用于描述而已调用 toSring 方法可以读取到这个描述 12var sym1 = Symbol('hello world')console.log(sym1) // Symbol(hello world) 即使传入完全一样的描述，所创建的 symbol 也是不相同的 123var sym1 = Symbol('hello world')var sym2 = Symbol('hello world')console.log(sym1 === sym2) // false 使用 symbolsymbol 用于对象属性时，不能使用点字符，只能用于计算属性 123var obj = &#123;&#125;var sym = Symbol('hello world')obj[sym] = 'hello Symbol' 重复使用一个 symbol前面说过 每一个 symbol 值都是独一无二的，但是有时候我们也需要共用一个 symbol ，这时候就需要用到 Symbol.for 这一方法了。 Symbol.for 方法接受一个 key 参数，根据这个 key 在全局的 Symbol 注册值中查找，如果之前已经通过 Symbol.for 方法和该key 创建过，那么就返回这个已经创建的 symbol 值，否则以 key 值创建一个，并注册一个全局值。下面这个例子可以比较 Symbol 和 Symbol.for 的不同 1234567var sym1 = Symbol('hello world')var sym2 = Symbol('hello world')console.log(sym1 === sym2) // falsevar sym3 = Symbol.for('global')var sym4 = Symbol.for('global')console.log(sym3 === sym4) // true 当要创建 sym4 时，由于之前 已经用 global 这个值创建了 sym3 ，因此会直接把 sym3 的值赋给 sym4 和 Symbol.for 对应的另一个方法是 Symbol.keyForSymbol.keyFor 方法接受一个 symbol 值作为参数，返回对应的 key 值 1234// 接上例console.log(Symbol.keyFor(sym3)) // globalconsole.log(Symbol.keyFor(sym4)) // globalconsole.log(Symbol.keyFor(sym1)) // undefined 基本上，Symbol 了解这些就已经足够日常使用了。剩下的一些零零散散的知识和一些 Well-known Symbol 之后抽空看看。]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
