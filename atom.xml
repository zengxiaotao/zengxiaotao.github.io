<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zengxiaotao&#39;s personal blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-10T13:40:22.367Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zengxiaotao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>compiler  Compilation</title>
    <link href="http://yoursite.com/posts/82e413ee/"/>
    <id>http://yoursite.com/posts/82e413ee/</id>
    <published>2018-12-10T06:43:12.000Z</published>
    <updated>2018-12-10T13:40:22.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><p>什么是 <code>compiler</code> 和 <code>compilation</code></p></li><li><p><code>compiler</code> 启动过程</p></li><li><p><code>compilation</code> 启动过程</p></li></ol><a id="more"></a><h1 id="compiler-和-compilation-v"><a href="#compiler-和-compilation-v" class="headerlink" title="compiler 和 compilation v"></a>compiler 和 compilation v</h1><p>先贴一张图，来自 <code>webpack</code> 官方的解释</p><blockquote><p>原文链接 <a href="https://github.com/webpack/docs/wiki/how-to-write-a-plugin" target="_blank" rel="noopener">how to write a webpack plugin</a></p></blockquote><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210145523.png" alt=""></p><p>简单翻译一下</p><p><code>compiler</code> 对象代表了一个 <code>webpack</code> 完整的配置环境，在 <code>webpack</code> 启动时构建，包括了所有的可操作的配置项，比如 <code>options</code> , <code>loaders</code> 和 <code>plugins</code>。</p><p><code>compilation</code> 对象则代表了一次 <strong>单次构建</strong>。每次文件变更的时候，都会开始一次新的编译。<code>compilation</code> 会提供以下信息：模块资源，已编译的文件，改变的文件，以及监听的依赖。</p><p>它们之间的关系是</p><p>options –&gt; Compiler -&gt; Compilation</p><h1 id="compiler-启动过程"><a href="#compiler-启动过程" class="headerlink" title="compiler 启动过程"></a>compiler 启动过程</h1><blockquote><p>源码地址 <a href="https://github.com/webpack/webpack/blob/master/lib/Compiler.js" target="_blank" rel="noopener">source</a></p></blockquote><p>先上一个总览</p><p>生成一个 <code>compiler</code> 主要经历以下几个过程</p><ol><li>开始编译</li></ol><p>相关的生命周期钩子 <code>beforeRun</code>, <code>run</code></p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210151951.png" alt=""></p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210152549.png" alt=""></p><ol start="2"><li>compile</li></ol><p>相关的生命周期钩子 <code>beforeCompile</code> 、<code>compile</code> 和 <code>make</code></p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210153023.png" alt=""></p><ol start="3"><li>make 阶段，从入口点分析模块及其依赖的模块，创建这些模块对象</li></ol><p>相关的生命周期钩子 <code>make</code></p><p>这一步会根据 <code>compiler</code> 对象生成一个 <code>compilation</code> 对象，并且完成 <code>compilation</code> 的 <code>finish</code>, <code>seal</code> 过程</p><ol start="4"><li><p>after-compilation 完成构建</p></li><li><p>记录编译信息</p></li></ol><p>相关的生命周期钩子 <code>shouldEmit</code>, </p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210153757.png" alt=""></p><ol start="6"><li>编译文件</li></ol><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210154258.png" alt=""></p><ol start="7"><li>记录 records</li></ol><blockquote><p>先说说什么是 records</p></blockquote><p>“用于存储跨多次构建(across multiple builds)的模块标识符的数据片段”。可以使用此文件来跟踪在每次构建之间的模块变化。</p><p>如果你使用了代码分离(code splittnig)这样的复杂配置，records 会特别有用。这些数据用于确保拆分 bundle，以便实现你需要的缓存(caching)行为。</p><p>只需要配置 <code>recordPath</code> 即可开启</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recordsPath: path.join(__dirname, <span class="string">'records.json'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210155902.png" alt=""></p><h2 id="compiler-全部生命周期"><a href="#compiler-全部生命周期" class="headerlink" title="compiler 全部生命周期"></a>compiler 全部生命周期</h2><h1 id="compilation-编译过程"><a href="#compilation-编译过程" class="headerlink" title="compilation 编译过程"></a><code>compilation</code> 编译过程</h1><h2 id="在-SingleEntryPlugin-里-调用addEntry"><a href="#在-SingleEntryPlugin-里-调用addEntry" class="headerlink" title="在 SingleEntryPlugin 里 调用addEntry"></a>在 SingleEntryPlugin 里 调用addEntry</h2><p>执行 <code>Compilation</code> 的构造函数，只是生成了一个 <code>compilation</code> 的实例对象，包含了一系列编译信息。</p><p>但是又是在哪触发了编译过程？？？</p><p>回到 <code>compiler</code> 里，在 <code>compile</code> 方法内，生成了 <code>compilation</code> 对象之后，紧接着会触发 <code>compiler</code> 的 <code>make</code> 钩子，按照之前讲的插件的写法，给生命周期注入钩子的写法，全局搜索 <code>compiler.hooks.make.tap.</code></p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210175924.png" alt=""></p><p>所以看到以下这7个插件，在<code>compiler</code> 的 <code>make</code> 生命周期注入了钩子。这里我们主要看 <code>SingleEntryPlugin.js</code> 这个文件。</p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210180202.png" alt=""></p><p>因此，在 <code>compiler</code> 的 <code>make</code> 阶段触发了 <code>compilation</code> 模块的构建</p><h2 id="addEntry"><a href="#addEntry" class="headerlink" title="addEntry"></a><code>addEntry</code></h2><p>在 <code>addEntry</code> 里并没有做太多操作，将传入的 <code>entry</code> 信息放入 <code>_preparedEntrypoints</code> 数组内，之后调用内部的 <code>_addModuleChain</code> 方法。</p><h2 id="addModuleChain"><a href="#addModuleChain" class="headerlink" title="_addModuleChain"></a><code>_addModuleChain</code></h2><p>在 <code>_addModuleChain</code> 内部会做两件事</p><ol><li>根据传入的 <code>dependency</code> 找到对应的 <code>ModuleFactory（模块工厂）</code>，调用模块工厂的 <code>create</code> 方法创建模块。</li></ol><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210182554.png" alt=""></p><ol start="2"><li>构建模块</li></ol><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210182637.png" alt=""></p><h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><h3 id="什么是-ModuleFactory（模块工厂）"><a href="#什么是-ModuleFactory（模块工厂）" class="headerlink" title="什么是 ModuleFactory（模块工厂）"></a>什么是 <code>ModuleFactory（模块工厂）</code></h3><p>回想一下，在写一个 <code>webpack.config.js</code> 时，是怎么写 <code>entry</code> 的。最常用的是一个字符串比如 <code>./src/index.js</code>。但是 <code>entry</code> 也支持数组，对象，函数等写法, </p><p>不同的写法对应的 模块工厂 如下</p><ul><li>string –&gt; normalModuleFactory</li><li>array –&gt; MultiModuleFactory</li><li>function -&gt; normalModuleFactory &amp;&amp; MultiModuleFactory</li></ul><p>因此也分别对应 <code>SingleEntryPlugin</code>、<code>MultiEntryPlugin</code> 和 <code>DynamicEntryPlugin</code> </p><p><a href="https://webpack.docschina.org/configuration/entry-context/" target="_blank" rel="noopener">webpack entry doc</a></p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210183505.png" alt=""></p><p>对于不同的 entry ，webpack 是如何选择不同的 <code>ModuleFactory</code> 。</p><p>在 <code>./EntryOptionPlugin</code> 内</p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210183819.png" alt=""></p><h3 id="normalModuleFactory"><a href="#normalModuleFactory" class="headerlink" title="normalModuleFactory"></a>normalModuleFactory</h3><h3 id="MainTemplate-和-chunkTemplate"><a href="#MainTemplate-和-chunkTemplate" class="headerlink" title="MainTemplate 和 chunkTemplate"></a>MainTemplate 和 chunkTemplate</h3><h3 id="createChunkAssets"><a href="#createChunkAssets" class="headerlink" title="createChunkAssets"></a>createChunkAssets</h3><p><code>createChunkAssets</code> 的作用是根据 <code>compilation</code> 的 <code>chunks</code> ，分析其中每一个 <code>chunk</code> 所包含的<code>文件(files)</code>，根据每一个 <code>file</code> 生成 <code>file</code> 的 <code>content string</code> 也就是 <code>source</code>, 将这些 <code>source</code> 统一放入 <code>this.assets</code> 对象内。</p><p>但注意的是，这里还没有写入文件。只是生成了一段文本。真正生成文件的工作，前面说过，会在 <code>compiler</code> 的 <code>emitAssets</code> 方法内。</p><p><img src="http://pjidtibsr.bkt.clouddn.com/images/20181210213905.png" alt=""></p><p>生成 <code>assets</code> 之后，进入到 <code>chunkAsset</code> 生命周期，如果你想对 <code>source</code> 做任何更改，这里是最佳时期。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是 &lt;code&gt;compiler&lt;/code&gt; 和 &lt;code&gt;compilation&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;compiler&lt;/code&gt; 启动过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;compilation&lt;/code&gt; 启动过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack源码解析(for webpack v4)</title>
    <link href="http://yoursite.com/posts/d5545be8/"/>
    <id>http://yoursite.com/posts/d5545be8/</id>
    <published>2018-10-21T04:33:41.000Z</published>
    <updated>2018-11-02T11:29:57.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>webpack-cli 工具介绍</li><li>webpack node api</li><li>webpack 启动过程</li><li>如何自己写一个 webpack plugin</li><li>如何自己写一个 webpack loader</li></ol><h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><h3 id="什么是-webpack-cli"><a href="#什么是-webpack-cli" class="headerlink" title="什么是 webpack-cli"></a>什么是 webpack-cli</h3><blockquote><p>webpack CLI is a CLI tool for providing a flexible set of commands for developers to increase speed when setting up a custom webpack project. As of webpack v4, webpack is not expecting a configuration file but often, developers want to create a more custom webpack configuration based on their use-cases and needs. Exactly all these cases with <strong>webpack CLI we are providing a set of tools to improve the setup of custom webpack configuration</strong>.</p></blockquote><p>随着 webpack 4.0.0 推出，webpack 将命令行的代码迁移到 webpack-cli。</p><p>Webpack-cli 提供了一系列的工具来增强 webpack 的可配置性。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 webpack 4.0.0 之后的版本，webpack-cli 不会随着 webpack 一起安装，当运行 <code>npx webpack</code> 之后，会提示安装 <code>webpack-cli</code> 或者 <code>webpack-command</code> 。但 <a href="https://github.com/webpack/webpack/pull/7966" target="_blank" rel="noopener">webpack-command 已经不推荐安装使用。</a>。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>webpack-cli 提供了很多常用的命令，包括 <code>init</code>, <code>add</code>, <code>info</code>, <code>migarate</code>, <code>remove</code>, <code>generate-loader</code>, <code>generate-plugin</code>, <code>serve</code>, <code>update</code>。</p><p>使用每种命令之前，都需要对命令单独安装，<code>npm install @webpack-cli/&lt;command&gt;</code>。分别介绍一下。</p><ol><li>init</li></ol><p>init 命令将会初始化一个 webpack 工程，将会在当前目录下新建一个 <code>webpack.prod.js</code> 文件, 包括一些常用的配置。</p><ol start="2"><li>add</li></ol><p>add 命令会询问一系列的问题，之后会在配置文件添加相关的属性，而不用自己手工配置。</p><ol start="3"><li>info</li></ol><p>运行 <code>info</code> 命令，将会输出一系列的系统信息。包括 <code>webpack</code>, <code>webpack-cli</code>, <code>node</code>, <code>npm</code> 和浏览器的版本信息。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102142236.png" alt=""></p><ol start="4"><li>migarate</li></ol><p>将你的 webpack 工程迁移到具体的webpack 上，会根据不同版本的 webpack 支持的特性，更改相对应的 webpack 配置。</p><ol start="5"><li>remove</li></ol><p>和 add 添加属性相反，remove 命令是移除对应的配置项。</p><ol start="6"><li>generate-loader</li></ol><p>如果想要自己写一个 webpack loader, 该命令会帮你生成一个 webpack loader 的工程目录。</p><ol start="7"><li>generate-plugin</li></ol><p>同理，会生成一个 webpack plugin 的工程目录。</p><ol start="8"><li>serve</li></ol><p>会启动一个 webpack-serve 服务。</p><ol start="9"><li>update</li></ol><p>该命令会将当前的 webpack 配置文件升级到新的版本，你可以选择要升级的 webpack 配置项。</p><h2 id="webpack-node-api"><a href="#webpack-node-api" class="headerlink" title="webpack node api"></a>webpack node api</h2><p>虽然通过 webpack 配置文件可以打包资源，通过各种 <code>plugin</code> 和 <code>loader</code> 可以满足我们大部分需要，但是 webpack node api 能帮助我们实现对配置选项更加精度的控制，通过 node api 生成的 compiler 对象,对其处理，能实现更高级别的功能。比如根据配置对象开启一个 node 服务。<br>常见的比如 webpack-dev-server 就是通过这种方式。</p><p>webpack-dev-serve/bin/webpack-dev-server.js</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102144516.png" alt=""></p><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br></pre></td></tr></table></figure><p>webpack 函数会接收 2 个参数，第一个参数就是传入的 options 配置对象，第二个参数为一个 callback 函数。<br>只传入配置对象时，将会生成一个 compiler 对象。如果传入了 callback , 则会自动执行 <code>compiler.run</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compiler = webpack(options, [callback]);</span><br></pre></td></tr></table></figure><p>compiler 会暴露出 <code>run</code> 和 <code>watch</code> 方法。<code>run</code> 方法会立即编译打包文件。<code>watch</code> 方法也会打包文件，但会自动监听文件变化，从而重新打包。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.run(<span class="function"><span class="keyword">function</span>(<span class="params">err,stats</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.watch(watchOptions, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="webpack-启动过程-源码部分"><a href="#webpack-启动过程-源码部分" class="headerlink" title="webpack 启动过程 (源码部分)"></a>webpack 启动过程 (源码部分)</h2><a id="more"></a><h2 id="输入-webpack-到底做了什么"><a href="#输入-webpack-到底做了什么" class="headerlink" title="输入 webpack 到底做了什么"></a>输入 webpack 到底做了什么</h2><blockquote><p>输入 webpack 会报错 command not found: webpack<br>正确的做法是 npx webpack</p></blockquote><p>webpack 4.0 之后，随之推出的还有 webpack-cli。</p><p>如果只安装了 webpack 而没有安装 webpack-cli，启动 webpack 的时候，会提醒你安装 webpack-cli 。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021124522.png" alt="remind info"></p><p>具体逻辑在 <code>webpack/cli/webpack.js</code> 内</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021125753.png" alt=""></p><p>成功安装 webpack-cli后，再次输入 npx webpack 之后, webpack-cli 将负责启动的逻辑。</p><h3 id="webpack-cli-1"><a href="#webpack-cli-1" class="headerlink" title="webpack-cli"></a>webpack-cli</h3><p><code>webpack-cli/bin/cli.js</code>。</p><p>在命令行输入 <code>npx webpack</code> 后，<code>cli.js</code> 会判断是编译相关的命令还是功能性命令。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021134009.png" alt=""></p><p>如果是非编译命令，会调用 <code>./prompt-command.js</code> 安装或执行对应的模块。</p><p><code>webpack-cli/bin/prompt-command.js</code></p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021134507.png" alt=""></p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021134606.png" alt=""></p><p>完成这些工作后，就会开始解析输入的 webpack 相关参数，开始编译文件(<code>webpack-cli/bin/cli-js line48</code>)。</p><p>之后是定义的一些 option 信息，可以通过 <code>npx webpack -h</code> 查看</p><h3 id="稍稍说一下-yargs"><a href="#稍稍说一下-yargs" class="headerlink" title="稍稍说一下 yargs"></a>稍稍说一下 <a href="https://www.npmjs.com/package/yargs" target="_blank" rel="noopener">yargs</a></h3><blockquote><p>Yargs helps you build interactive command line tools, by parsing arguments and generating an elegant user interface.</p></blockquote><p>yargs 同 <a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener">commander</a> 类似，都是 构建 cli 工具，目前在 npm 上的周下载量已经超过了 commander 。</p><p>yargs.parse 方法。</p><p><code>.parse</code> 方法负责解析在命令行传入的 webpack 编译选项，方法接收 3 个参数，分别是传入的 argv, context, 以及解析完成后的 callback。</p><p>callback 方法同样接收 3 个参数，err, argv 表示解析的 argv 对象，以及在命令行输出的 output。</p><p>举个栗子。</p><p>当输入的选项为 <code>npx webpack --config webpack.config.js --silence</code>。解析完成后，callback 拿到的 argv 对象如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">_</span>: [],</span><br><span class="line">  cache: <span class="literal">null</span>,</span><br><span class="line">  bail: <span class="literal">null</span>,</span><br><span class="line">  profile: <span class="literal">null</span>,</span><br><span class="line">  color: [<span class="built_in">Function</span>: getSupportLevel],</span><br><span class="line">  colors: [<span class="built_in">Function</span>: getSupportLevel],</span><br><span class="line">  config: <span class="string">'webpack.config.js'</span>, <span class="comment">//</span></span><br><span class="line">  silence: <span class="literal">true</span>, <span class="comment">//</span></span><br><span class="line">  <span class="string">'info-verbosity'</span>: <span class="string">'info'</span>,</span><br><span class="line">  infoVerbosity: <span class="string">'info'</span>,</span><br><span class="line">  <span class="string">'$0'</span>: <span class="string">'node_modules/.bin/webpack'</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>从 249 行开始，就开始正式处理传入的编译选项。</p><p>首先还是惯例的错误处理。之后通过 <code>ifArg</code> 方法，将传入的 argv 转化成 <code>webpack</code> 可用的 option, 生成 compiler 对象，之后判断是否传入了 <code>watch</code> 选项，从而决定是执行 <code>compiler</code> 的 <code>run</code> 方法还是 <code>watch</code> 方法。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021155409.png" alt=""></p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021155508.png" alt=""></p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>输入 npx webpack 后到底会发生什么？</p><ol><li>webpack/bin/cli.js 会检查是否安装了 webpack-cli。(一般是 webpack-cli ，其实也可以是 webpack-command)。</li><li>如果安装了 webpack-cli ，调用对应的 bin 文件。否则安装 webpack-cli。</li><li>wepack-cli/bin/cli.js 会解析传入的命令行参数。如果不是编译相关的参数，会安装对应的功能模块。如果是确实要进行编译，调用 webpack 生成 compiler 对象，之后通过 run 或者 watch 方法生成编译文件。</li></ol><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p><code>webpack/lib/webpack.js</code></p><p>传入 option 进行错误检查之后，如果是个数组，会调用 Multicompiler ，如果只是个普通对象，也就是我们最常用的那种，调用 compiler 生成 compiler 对象。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021174212.png" alt=""></p><ol><li>设置默认 option 对象</li></ol><p>webpack v4 之前，webpack 最少只需要 <code>entry</code> 和 <code>output</code> 两个配置项即可。当零配置构建工具 Parcel 推出后，webpack v4 把这两个配置项也取消了，也实现了零配置。但是你的项目下必须要有 <code>src/index.js</code> 。所以，这些是如何完成的？</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021180016.png" alt=""></p><p><code>webpack/lib/WebpackOptionsDefaulter.js</code></p><p>映入眼帘的是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackOptionsDefaulter</span> <span class="keyword">extends</span> <span class="title">OptionsDefaulter</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>所以看看 <code>webpack/lib/OptionsDefaulter.js</code>。</p><p>OptionDefaulter 上实现了 <code>set</code> 方法和 <code>process</code> 方法供 <code>WebpackOptionDefault</code> 使用。</p><p>在 <code>WebpackOptionDefaulter</code> 的构造函数里即完成了所有默认选项的配置。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021181517.png" alt=""></p><ol start="2"><li>对生成的 compiler 应用 plugins </li></ol><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181021182700.png" alt=""></p><ol start="3"><li><p>根据 callback 以及 watch 选项来决定，执行 compiler 的 watch 方法或者 run 方法。</p></li><li><p>在 webpack 上挂载内部插件。</p></li></ol><h2 id="如何自己写一个-webpack-plugin"><a href="#如何自己写一个-webpack-plugin" class="headerlink" title="如何自己写一个 webpack plugin"></a>如何自己写一个 webpack plugin</h2><p><a href="https://github.com/webpack/docs/wiki/how-to-write-a-plugin" target="_blank" rel="noopener">参考链接</a></p><p>一个 webpack plugin 本质上是一个是一个构造函数，生成的 plugin 实例继承原型上的 <code>apply</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SimplestPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插件的配置对象</span></span><br><span class="line">&#125;</span><br><span class="line">SimplestPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is a webpack plugin'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个最简单的一个 plugin。使用方式同平常的插件一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimplestPlugin = <span class="built_in">require</span>(<span class="string">'pathToYourPlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> SimplestPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply 方法接收webpack 生成的 compiler 作为参数, 我们可以在插件内部对 complier 进行处理，或者在不同阶段触发钩子函数。</p><h3 id="compiler-钩子"><a href="#compiler-钩子" class="headerlink" title="compiler 钩子"></a>compiler 钩子</h3><p>Compiler 继承自 Tapable 。Tapable 是 webpack 内部自己实现的一个用于事件发布订阅执行的插件架构。这里先不介绍了。</p><p>compiler 对象会暴露出 webpack 不同生命周期钩子函数</p><p><a href="https://webpack.docschina.org/api/compiler-hooks/" target="_blank" rel="noopener">具体的可以在文档中查到</a></p><p>具体的触发方式, 比如在 emit 和 done 两个生命周期触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.emit.tap(<span class="string">'SimplestPlugin'</span>, (params) =&gt; &#123;&#125;)</span><br><span class="line">compiler.hooks.done.tap(<span class="string">'SimplestPlugin'</span>, (params) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><p>要注意的是，在不同的生命周期阶段内，传入回调函数的 params 并不是一成不变的。</p><p>比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimplestPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.hooks.emit.tap(<span class="string">'SimplestPlugin'</span>, (params) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params.contructor);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102161023.png" alt=""><br>可以看到，在 emit 阶段传给回调函数的是 <code>Compilation</code> 的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimplestPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.hooks.done.tap(<span class="string">'SimplestPlugin'</span>, (params) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params.contructor);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102161132.png" alt=""></p><p>而在 done 阶段，传给回调函数的参数变成了 <code>Stats</code> 的实例。</p><h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>这种写法目前已经废弃，但是在网上的一些教程里还是能经常看到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimplestPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.plugin(<span class="string">'done'</span>, (params) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params.contructor);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102161954.png" alt=""></p><p>这种方法仍然能够使用，但是会提示废弃信息，所以建议以第一种方式为主。</p><h3 id="compilation-钩子"><a href="#compilation-钩子" class="headerlink" title="compilation 钩子"></a>compilation 钩子</h3><p>compilation 钩子的使用方法和 compiler 钩子的使用方法一样。在 compilation 的生命周期的不同阶段，可以对 compilation 进行处理。</p><p><a href="https://webpack.docschina.org/api/compilation-hooks/" target="_blank" rel="noopener">compilation 的生命周期钩子可以看这</a></p><h3 id="一个稍微复杂点的例子"><a href="#一个稍微复杂点的例子" class="headerlink" title="一个稍微复杂点的例子"></a>一个稍微复杂点的例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SimplestPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插件的配置对象</span></span><br><span class="line">  <span class="keyword">this</span>._options = <span class="keyword">this</span>.options;</span><br><span class="line">  <span class="keyword">this</span>.filename = options.filename;</span><br><span class="line">&#125;</span><br><span class="line">SimplestPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> filename;</span><br><span class="line">  <span class="keyword">let</span> filepath;</span><br><span class="line">  compiler.hooks.emit.tap(<span class="string">'SimplestPlugin'</span>, compilation =&gt; &#123;</span><br><span class="line">    filename = <span class="keyword">this</span>.filename || compilation.hash;</span><br><span class="line">    filepath = <span class="string">`<span class="subst">$&#123;filename&#125;</span>.json`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  compiler.hooks.done.tap(<span class="string">'SimplestPlugin'</span>, stats =&gt; &#123;</span><br><span class="line">    fs.writeFileSync(filepath, <span class="built_in">JSON</span>.stringify(stats.compilation.options))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该插件后，每次编译完成都会将本次编译的 webpack 配置保存到文件中, 文件名为本次编译的 hash 值。</p><h3 id="compilation-对象"><a href="#compilation-对象" class="headerlink" title="compilation 对象"></a>compilation 对象</h3><p>每个 compilation 对象代表一次编译，可以从里面获得本次编译的一些有用信息。</p><ol><li><code>compliation.modules</code>: 每一个资源文件都会编译成一个模块，每一个 module 会有一个 fileDependencies 属性，记录了这个模块的所有依赖项。</li><li><code>compilation.chunks</code>: 是entry的每个配置项及调用require.ensure的模块，每个chunk的， chunk.modules为chunk包含的模块以及模块所依赖的模块， chunk.files为每个配置项最后的输出结果文件.</li><li><code>compilation.assets</code>: 整个打包流程最终要输出的文件, 通过 <code>compilation.assets[filename].source()</code>可以获取到每个生成的的文件的内容。</li></ol><h2 id="如何写一个-webpack-loader"><a href="#如何写一个-webpack-loader" class="headerlink" title="如何写一个 webpack loader"></a>如何写一个 webpack loader</h2><p>相比于写一个 webpack plugin ，写一个 webpack 的 loader 就相对简单得多</p><h3 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h3><p><a href="https://webpack.docschina.org/api/loaders/" target="_blank" rel="noopener">参考链接</a></p><p>一个 webpack loader 本质上就是一个函数，函数接收3个参数，分别是 文件内容的 <code>content</code>, 文件的 <code>sourceMap</code>, 以及一个 <code>meta</code>。</p><h3 id="一个最基本的例子"><a href="#一个最基本的例子" class="headerlink" title="一个最基本的例子"></a>一个最基本的例子</h3><p>最近做的需求很多时候会和 <code>csv</code> 文件打交道，例如 csv 的解析和生成。如果可以交给 loader 来做，应该是这样</p><p>假设这里有一个 csv 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b,c</span><br><span class="line">1,2,3</span><br><span class="line">2,4,6</span><br></pre></td></tr></table></figure><p>假设需要统计出每一个 csv 文件的长度。</p><p>在 node_modules 文件夹内(假设还未发布到 npm), 新建一个 <code>test-csv-loader</code> 文件夹，文件夹内只需要一个 <code>index.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">countCsvLength</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(content);</span><br><span class="line">  <span class="keyword">const</span> length = content.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports=function() &#123;return <span class="subst">$&#123;length&#125;</span>&#125;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 loader 就完成了，之后在配置文件中引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.csv$/</span><span class="string">',</span></span><br><span class="line"><span class="string">        loader: '</span>test-csv-loader<span class="string">',</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>执行 <code>npx webpack</code>,</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102180940.png" alt=""></p><p>打包成功了。</p><p>在生成的 <code>dist/main.js</code> 中可以看到这一段。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102181150.png" alt=""></p><p>项目的 <code>src/index.js</code> 内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'../a.csv'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a());</span><br></pre></td></tr></table></figure><p>执行 <code>dist/main.js</code>，得到了预想中的结果。</p><p><img src="http://pcjaqb4ci.bkt.clouddn.com/images/20181102181451.png" alt=""></p><p>以上。</p><p>对 <code>content</code> 进行处理基本上能解决平时遇到的小需求。更高级的用法可以看文档深究。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;webpack-cli 工具介绍&lt;/li&gt;
&lt;li&gt;webpack node api&lt;/li&gt;
&lt;li&gt;webpack 启动过程&lt;/li&gt;
&lt;li&gt;如何自己写一个 webpack plugin&lt;/li&gt;
&lt;li&gt;如何自己写一个 webpack loader&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;webpack-cli&quot;&gt;&lt;a href=&quot;#webpack-cli&quot; class=&quot;headerlink&quot; title=&quot;webpack-cli&quot;&gt;&lt;/a&gt;webpack-cli&lt;/h2&gt;&lt;h3 id=&quot;什么是-webpack-cli&quot;&gt;&lt;a href=&quot;#什么是-webpack-cli&quot; class=&quot;headerlink&quot; title=&quot;什么是 webpack-cli&quot;&gt;&lt;/a&gt;什么是 webpack-cli&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;webpack CLI is a CLI tool for providing a flexible set of commands for developers to increase speed when setting up a custom webpack project. As of webpack v4, webpack is not expecting a configuration file but often, developers want to create a more custom webpack configuration based on their use-cases and needs. Exactly all these cases with &lt;strong&gt;webpack CLI we are providing a set of tools to improve the setup of custom webpack configuration&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着 webpack 4.0.0 推出，webpack 将命令行的代码迁移到 webpack-cli。&lt;/p&gt;
&lt;p&gt;Webpack-cli 提供了一系列的工具来增强 webpack 的可配置性。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;安装 webpack 4.0.0 之后的版本，webpack-cli 不会随着 webpack 一起安装，当运行 &lt;code&gt;npx webpack&lt;/code&gt; 之后，会提示安装 &lt;code&gt;webpack-cli&lt;/code&gt; 或者 &lt;code&gt;webpack-command&lt;/code&gt; 。但 &lt;a href=&quot;https://github.com/webpack/webpack/pull/7966&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webpack-command 已经不推荐安装使用。&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;webpack-cli 提供了很多常用的命令，包括 &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;migarate&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;generate-loader&lt;/code&gt;, &lt;code&gt;generate-plugin&lt;/code&gt;, &lt;code&gt;serve&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用每种命令之前，都需要对命令单独安装，&lt;code&gt;npm install @webpack-cli/&amp;lt;command&amp;gt;&lt;/code&gt;。分别介绍一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;init&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;init 命令将会初始化一个 webpack 工程，将会在当前目录下新建一个 &lt;code&gt;webpack.prod.js&lt;/code&gt; 文件, 包括一些常用的配置。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;add&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;add 命令会询问一系列的问题，之后会在配置文件添加相关的属性，而不用自己手工配置。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;info&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;运行 &lt;code&gt;info&lt;/code&gt; 命令，将会输出一系列的系统信息。包括 &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;webpack-cli&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;npm&lt;/code&gt; 和浏览器的版本信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcjaqb4ci.bkt.clouddn.com/images/20181102142236.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;migarate&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将你的 webpack 工程迁移到具体的webpack 上，会根据不同版本的 webpack 支持的特性，更改相对应的 webpack 配置。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;remove&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和 add 添加属性相反，remove 命令是移除对应的配置项。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;generate-loader&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果想要自己写一个 webpack loader, 该命令会帮你生成一个 webpack loader 的工程目录。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;generate-plugin&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同理，会生成一个 webpack plugin 的工程目录。&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;serve&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;会启动一个 webpack-serve 服务。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该命令会将当前的 webpack 配置文件升级到新的版本，你可以选择要升级的 webpack 配置项。&lt;/p&gt;
&lt;h2 id=&quot;webpack-node-api&quot;&gt;&lt;a href=&quot;#webpack-node-api&quot; class=&quot;headerlink&quot; title=&quot;webpack node api&quot;&gt;&lt;/a&gt;webpack node api&lt;/h2&gt;&lt;p&gt;虽然通过 webpack 配置文件可以打包资源，通过各种 &lt;code&gt;plugin&lt;/code&gt; 和 &lt;code&gt;loader&lt;/code&gt; 可以满足我们大部分需要，但是 webpack node api 能帮助我们实现对配置选项更加精度的控制，通过 node api 生成的 compiler 对象,对其处理，能实现更高级别的功能。比如根据配置对象开启一个 node 服务。&lt;br&gt;常见的比如 webpack-dev-server 就是通过这种方式。&lt;/p&gt;
&lt;p&gt;webpack-dev-serve/bin/webpack-dev-server.js&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcjaqb4ci.bkt.clouddn.com/images/20181102144516.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;compiler&quot;&gt;&lt;a href=&quot;#compiler&quot; class=&quot;headerlink&quot; title=&quot;compiler&quot;&gt;&lt;/a&gt;compiler&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; webpack = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;webpack&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;webpack 函数会接收 2 个参数，第一个参数就是传入的 options 配置对象，第二个参数为一个 callback 函数。&lt;br&gt;只传入配置对象时，将会生成一个 compiler 对象。如果传入了 callback , 则会自动执行 &lt;code&gt;compiler.run&lt;/code&gt; 方法&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; compiler = webpack(options, [callback]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;compiler 会暴露出 &lt;code&gt;run&lt;/code&gt; 和 &lt;code&gt;watch&lt;/code&gt; 方法。&lt;code&gt;run&lt;/code&gt; 方法会立即编译打包文件。&lt;code&gt;watch&lt;/code&gt; 方法也会打包文件，但会自动监听文件变化，从而重新打包。&lt;/p&gt;
&lt;h3 id=&quot;run&quot;&gt;&lt;a href=&quot;#run&quot; class=&quot;headerlink&quot; title=&quot;run&quot;&gt;&lt;/a&gt;run&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compiler.run(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,stats&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;watch&quot;&gt;&lt;a href=&quot;#watch&quot; class=&quot;headerlink&quot; title=&quot;watch&quot;&gt;&lt;/a&gt;watch&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compiler.watch(watchOptions, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, stats&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;webpack-启动过程-源码部分&quot;&gt;&lt;a href=&quot;#webpack-启动过程-源码部分&quot; class=&quot;headerlink&quot; title=&quot;webpack 启动过程 (源码部分)&quot;&gt;&lt;/a&gt;webpack 启动过程 (源码部分)&lt;/h2&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>【译】对象扩展符简易指南</title>
    <link href="http://yoursite.com/posts/adc6686/"/>
    <id>http://yoursite.com/posts/adc6686/</id>
    <published>2018-04-28T11:02:23.000Z</published>
    <updated>2018-05-07T12:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>合并多个 Javascript 对象是常见的工作，但不好的是，至少到目前，Javascript 仍然没有一种方便的方法来完成这个工作。至少现在是这样。</p><p>在 ES5 时代，你可以使用 Lodash 的 <code>_.extend(target, [sources])</code> 方法，而 ES2015 则引入了 <code>Object.assign(target, [sources])</code> 方法。</p><a id="more"></a><p>幸运的是，<a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">对象扩展符</a> (an ECMASript proposal at stage 3) 是一个很大的进步，提供了简单方便的如下简介方便的语法。</p><p><a href="https://repl.it/@panzerdp/FearlessLovableUintagroundsquirrel" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;   </span><br><span class="line">  legs: <span class="number">4</span>,</span><br><span class="line">  sound: <span class="string">'meow'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> dog = &#123;  </span><br><span class="line">  ...cat,</span><br><span class="line">  sound: <span class="string">'woof'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog); <span class="comment">// =&gt; &#123; legs: 4, sounds: 'woof' &#125;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>...cat</code> 复制 <code>cat</code> 的属性到一个新对象 <code>dog</code> 中，<code>cat</code> 中原来的属性 <code>sound</code> 被覆盖，最终值为 <code>woof</code>。</p><p>本篇文章将介绍对象 spread 和 rest 语法。包括如何实现对象克隆，对象合并，以及如何覆盖属性值。</p><p>下面是关于可枚举属性的简单和概括，以及如何分辨对象自有属性和继承属性。</p><h3 id="1-可枚举以及自有属性"><a href="#1-可枚举以及自有属性" class="headerlink" title="1. 可枚举以及自有属性"></a>1. 可枚举以及自有属性</h3><p>Javascript 里的对象是键值对的组合。</p><p>键名通常是一个字符串或者一个 symbol 。值可以是一个原始类型的值(string, boolean, number, <code>undefined</code> 或者 <code>null</code>)，一个对象或者一个函数。</p><p>下面这个例子将通过对象字面量语法创建一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;  </span><br><span class="line">  name: <span class="string">'Dave'</span>,</span><br><span class="line">  surname: <span class="string">'Bowman'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>person</code> 这个对象描述了一个人的名和姓氏。</p><h4 id="1-1-可枚举属性"><a href="#1-1-可枚举属性" class="headerlink" title="1.1 可枚举属性"></a>1.1 可枚举属性</h4><p>描述一个属性有几种描述符，如 writable、enumerable 和configurable 。你可以看这篇文章<a href="http://2ality.com/2012/10/javascript-properties.html" target="_blank" rel="noopener">Object properties in JavaScript</a>了解更多细节。</p><p><em>Enumerable</em> 描述符是一个布尔值，表示这个属性是否可以被枚举。</p><p>你可以通过 <code>Object.keys()</code> 方法来枚举一个对象的自有属性和可枚举属性，通过 <code>for..in</code> 语句来枚举所有可枚举的属性。</p><p>以对象字面量的形式创建对象 <code>{ prop1: &#39;val1&#39;, prop2: &#39;val2&#39; }</code> 时显式声明的属性都是可枚举的。接下来看看之前创建的 <code>person</code> 对象有哪些可枚举的属性。</p><p><a href="https://repl.it/@panzerdp/UnrulyYearlyAmericanlobster" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(person);  </span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// =&gt; ['name', 'surname']</span></span><br></pre></td></tr></table></figure><p><code>.name</code> 和 <code>.surname</code> 是 <code>person</code> 对象的可枚举属性</p><p>接下来是有趣的一部分。<em>对象扩展符复制了原对象的所有可枚举属性。</em></p><p><a href="https://repl.it/@panzerdp/DependentUnevenIberianmidwifetoad" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123; ...person &#125;; <span class="comment">// =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125;</span></span><br></pre></td></tr></table></figure><p>下面我们在 <code>person</code> 对象上创建一个不可枚举属性 <code>.age</code>。</p><p><a href="https://repl.it/@panzerdp/SameFirmBlackrhino" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'age'</span>, &#123;  </span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// Make the property non-enumerable</span></span><br><span class="line">  value: <span class="number">25</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'age'</span>]); <span class="comment">// =&gt; 25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clone = &#123;  </span><br><span class="line">  ...person</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(clone); <span class="comment">// =&gt; &#123; name: 'Dave', surname: 'Bowman' &#125;</span></span><br></pre></td></tr></table></figure><p>目标对象 <code>clone</code> 从源对象 <code>person</code> 上创建了可枚举属性 <code>.name</code> 和 <code>.surname</code> ，但是不可枚举属性 <code>.age</code> 则被忽略掉。</p><h3 id="1-2-自有属性"><a href="#1-2-自有属性" class="headerlink" title="1.2 自有属性"></a>1.2 自有属性</h3><p>Javascript 内有原型继承机制，因此一个对象上既有 <strong>自有</strong>属性，也有从<strong>继承</strong>属性。</p><p>对象字面量显式声明的属性都是<strong>自有</strong>属性，存在于原型链上的属性都是 <strong>继承</strong> 属性。</p><p>下面将创建一个 <code>personB</code> 对象，并将 <code>person</code> 对象设置成其原型对象。</p><p><a href="https://repl.it/@panzerdp/MonumentalUnimportantAmericancrayfish" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personB = <span class="built_in">Object</span>.create(person, &#123;  </span><br><span class="line">  profession: &#123;</span><br><span class="line">    value: <span class="string">'Astronaut'</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personB.hasOwnProperty(<span class="string">'profession'</span>)); <span class="comment">// =&gt; true  </span></span><br><span class="line"><span class="built_in">console</span>.log(personB.hasOwnProperty(<span class="string">'name'</span>));       <span class="comment">// =&gt; false  </span></span><br><span class="line"><span class="built_in">console</span>.log(personB.hasOwnProperty(<span class="string">'surname'</span>));    <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>现在 <code>personB</code> 上有自有的 <code>.profession</code> 属性，以及从原型对象 <code>person</code> 上继承来的 <code>.name</code> 和 <code>.surname</code> 属性。</p><p><em>对象扩展符从源对象上复制<strong>自有</strong>属性，而会忽略继承的属性</em></p><p><a href="https://repl.it/@panzerdp/OccasionalThirstyMinibeast" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloneB = &#123;  </span><br><span class="line">  ...personB</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(cloneB); <span class="comment">// =&gt; &#123; profession: 'Astronaut' &#125;</span></span><br></pre></td></tr></table></figure><p><code>...personB</code> 只从 <code>personB</code> 上复制了 <code>.profession</code> 这个自有属性，而继承属性 <code>.name</code> 和 <code>.surname</code> 则被忽略。</p><blockquote><p>总结： 对象扩展符号只会从源对象上复制 <strong>自有和可枚举属性</strong>，这和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">Object.keys()</a> 方法的返回值一样。</p></blockquote><h3 id="2-对象扩展属性"><a href="#2-对象扩展属性" class="headerlink" title="2. 对象扩展属性"></a>2. 对象扩展属性</h3><p>在对象字面量里，<strong>对象扩展符</strong>将<strong>源对象</strong>里的自有属性和可枚举属性复制进<strong>目标对象</strong>内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObject = &#123;  </span><br><span class="line">  ...sourceObject,</span><br><span class="line">  property: <span class="string">'Value'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>顺便说一下，很多时候，对象扩展符与 <code>Object.assign()</code> 等价，上面的代码也可以用这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObject = <span class="built_in">Object</span>.assign(  </span><br><span class="line">  &#123; &#125;, </span><br><span class="line">  sourceObject,</span><br><span class="line">  &#123; <span class="attr">property</span>: <span class="string">'Value'</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个对象字面量里可以使用多个对象扩展符，与普通的属性声明同时使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObject = &#123;  </span><br><span class="line">  ...sourceObject1,</span><br><span class="line">  property1: <span class="string">'Value 1'</span>,</span><br><span class="line">  ...sourceObject2,</span><br><span class="line">  ...sourceObject3,</span><br><span class="line">  property2: <span class="string">'Value 2'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-1-对象扩展规则：后面的属性会覆盖前面的"><a href="#2-1-对象扩展规则：后面的属性会覆盖前面的" class="headerlink" title="2.1 对象扩展规则：后面的属性会覆盖前面的"></a>2.1 对象扩展规则：后面的属性会覆盖前面的</h4><p>当同时扩展多个对象时，这个对象内可能会存在同名属性，那么最终生成的对象的属性值是怎么计算的，规则很简单：<strong>后扩展的属性会覆盖之前扩展的属性</strong>。</p><p>来看一些简单的例子。下面的代码会实例化一只 cat 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;  </span><br><span class="line">  sound: <span class="string">'meow'</span>,</span><br><span class="line">  legs: <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们要变一个魔术，将这只猫变成一只狗，注意 <code>.sound</code> 属性值如何变化。</p><p><a href="https://repl.it/@panzerdp/LightgraySleepyRooster" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;  </span><br><span class="line">  ...cat,</span><br><span class="line">  ...&#123;</span><br><span class="line">    sound: <span class="string">'woof'</span> <span class="comment">// `&lt;----- Overwrites cat.sound</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(dog); <span class="comment">// =&gt;` &#123; sound: 'woof', legs: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>后面声明的 <code>·woof·</code> 属性值覆盖了前面的在 <code>cat</code> 对象声明的属性值 <code>&#39;meow&#39;</code> , 符合之前所说的规则: 对于同名属性，后声明的值覆盖先声明的值。</p><p>这个规则同样适用于对象的初始化</p><p><a href="https://repl.it/@panzerdp/CloudyTotalAnophelesmosquito" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anotherDog = &#123;  </span><br><span class="line">  ...cat,</span><br><span class="line">  sound: <span class="string">'woof'</span> <span class="comment">// `&lt;---- Overwrites cat.sound</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(anotherDog); <span class="comment">// =&gt;` &#123; sound: 'woof', legs: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码里，<code>sound: &#39;woof&#39;</code> 同样覆盖了之前声明的 <code>&#39; meow&#39;</code> 值。</p><p>现在，交换一下扩展对象的位置，输出了不同的结果。</p><p><a href="https://repl.it/@panzerdp/CharmingAwfulChimneyswift" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stillCat = &#123;  </span><br><span class="line">  ...&#123;</span><br><span class="line">    sound: <span class="string">'woof'</span> <span class="comment">// `&lt;---- Is overwritten by cat.sound</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...cat</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(stillCat); <span class="comment">// =&gt;` &#123; sound: 'meow', legs: 4 &#125;</span></span><br></pre></td></tr></table></figure><p><code>cat</code> 对象仍然是 <code>cat</code> 对象。虽然第一个源对象内的 <code>.sound</code> 属性值是 <code>&#39;woof&#39;</code> ，但是被之后 <code>cat</code> 对象的 <code>&#39;meow&#39;</code> 覆盖。</p><p>普通属性和对象扩展的相对位置非常重要，这将直接影响到对象克隆，对象合并，以及填充默认属性的结果。</p><p>下面分别详细介绍。</p><h3 id="2-2-克隆对象"><a href="#2-2-克隆对象" class="headerlink" title="2.2 克隆对象"></a>2.2 克隆对象</h3><p>用对象扩展符克隆一个对象非常简洁，下面的代码克隆了一个 <code>bird</code> 对象。</p><p><a href="https://repl.it/@panzerdp/InsubstantialUnnaturalJabiru" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;  </span><br><span class="line">  type: <span class="string">'pigeon'</span>,</span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> birdClone = &#123;  </span><br><span class="line">  ...bird</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(birdClone); <span class="comment">// =&gt; &#123; type: 'pigeon', color: 'white' &#125;  </span></span><br><span class="line"><span class="built_in">console</span>.log(bird === birdClone); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p><code>...bird</code> 将 <code>bird</code> 对象的自有和可枚举属性复制到目标对象 <code>birdClone</code> 内。</p><p>虽然克隆看起来很简单，但仍然要注意其中的几个细微之处。</p><h4 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h4><p>对象扩展只是对对象进行了 <em>浅复制</em>, 只有对象自身被复制，而嵌套的对象结构 <em>没有被复制</em>。</p><p><code>laptop</code> 对象有一个嵌套对象 <code>laptop.screen</code>。现在我们来克隆 <code>laptop</code>对象来看看其内部的嵌套对象怎么变化。</p><p><a href="https://repl.it/@panzerdp/WellmadeEnlightenedTurtle" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> laptop = &#123;  </span><br><span class="line">  name: <span class="string">'MacBook Pro'</span>,</span><br><span class="line">  screen: &#123;</span><br><span class="line">    size: <span class="number">17</span>,</span><br><span class="line">    isRetina: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> laptopClone = &#123;  </span><br><span class="line">  ...laptop</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(laptop === laptopClone);               <span class="comment">// =&gt; false  </span></span><br><span class="line"><span class="built_in">console</span>.log(laptop.screen === laptopClone.screen); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>第一个比较语句 <code>laptop === laptopClone</code> 的值为 <code>false</code>, 说明主对象被正确克隆。</p><p>然而 <code>laptop.screen === laptopClone.screen</code> 的计算结果为 <code>true</code> ，说明 <code>laptopClone.screen</code> 没有被复制，而是 <code>laptop.screen</code> 和 <code>laptopClone.screen</code> 引用了同一个嵌套对象。</p><p>好的一点是，你可以在对象的任何一层使用对象扩展符，只需要再多做一点工作就同样可以克隆一个嵌套对象。</p><p><a href="https://repl.it/@panzerdp/CyanSoreColt" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> laptopDeepClone = &#123;  </span><br><span class="line">  ...laptop,</span><br><span class="line">  screen: &#123;</span><br><span class="line">     ...laptop.screen</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(laptop === laptopDeepClone);               <span class="comment">// =&gt; false  </span></span><br><span class="line"><span class="built_in">console</span>.log(laptop.screen === laptopDeepClone.screen); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>使用 <code>...laptop.screen</code> 使嵌套对象也被克隆，现在 <code>laptopDeepClone</code> 完全克隆了 <code>laptop</code>。</p><h4 id="原型失去了"><a href="#原型失去了" class="headerlink" title="原型失去了"></a>原型失去了</h4><p>下面的代码声明了一个 <code>Game</code> 类，并创造了一个 <code>doom</code>实例。</p><p><a href="https://repl.it/@panzerdp/TediousProbableMuskox" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMessage() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`I like <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doom = <span class="keyword">new</span> Game(<span class="string">'Doom'</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(doom <span class="keyword">instanceof</span> Game); <span class="comment">// =&gt; true  </span></span><br><span class="line"><span class="built_in">console</span>.log(doom.name);            <span class="comment">// =&gt; "Doom"  </span></span><br><span class="line"><span class="built_in">console</span>.log(doom.getMessage());    <span class="comment">// =&gt; "I like Doom!"</span></span><br></pre></td></tr></table></figure><p>现在我们克隆一个通过构造函数创建的 <code>doom</code> 实例，结果可能与你想的不同。</p><p><a href="https://repl.it/@panzerdp/HummingFatalEthiopianwolf" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doomClone = &#123;  </span><br><span class="line">  ...doom</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doomClone <span class="keyword">instanceof</span> Game); <span class="comment">// =&gt; false  </span></span><br><span class="line"><span class="built_in">console</span>.log(doomClone.name);            <span class="comment">// =&gt; "Doom"  </span></span><br><span class="line"><span class="built_in">console</span>.log(doomClone.getMessage());  </span><br><span class="line"><span class="comment">// TypeError: doomClone.getMessage is not a function</span></span><br></pre></td></tr></table></figure><p><code>...doom</code> 将自有属性 <code>.name</code> 属性复制到 <code>doomClone</code> 内。</p><p><code>doomClone</code> 现在只是一个普通的 JavaScript 对象，它的原型是 <code>Object.prototype</code> 而不是预想中的<code>Game.prototype</code>。<em>对象扩展不保留源对象的原型。</em></p><p>因此调用 <code>doomClone.getMessage()</code> 方法会抛出一个 <code>TypeError</code> 错误，因此 <code>doomClone</code> 没有继承 <code>getMessage()</code> 方法。</p><p>当然我们可以手动在克隆对象上加上 <code>__proto__</code> 属性来结局这个问题。</p><p><a href="https://repl.it/@panzerdp/PreciousGroundedJuliabutterfly" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doomFullClone = &#123;  </span><br><span class="line">  ...doom,</span><br><span class="line">  __proto__: Game.prototype</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doomFullClone <span class="keyword">instanceof</span> Game); <span class="comment">// =&gt; true  </span></span><br><span class="line"><span class="built_in">console</span>.log(doomFullClone.name);            <span class="comment">// =&gt; "Doom"  </span></span><br><span class="line"><span class="built_in">console</span>.log(doomFullClone.getMessage());    <span class="comment">// =&gt; "I like Doom!"</span></span><br></pre></td></tr></table></figure><p>对象字面量内部的 <code>__proto__</code> 属性确保了 <code>doomFullClone</code> 的原型为 <code>Game.prototype</code>。</p><p><em>尽量不要尝试这种方法</em>。<code>__proto__</code> 属性已经废弃，这里使用它只是为了论证前面的观点。</p><p>对象扩展的目的是以浅复制的方式扩展自有和可枚举属性，因此不保留源对象的原型似乎也说得过去。</p><p>例外，这里用 <code>Object.assign()</code> 来克隆 <code>doom</code> 更加合理。</p><p><a href="https://repl.it/@panzerdp/DecentUnsteadyGavial" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doomFullClone = <span class="built_in">Object</span>.assign(<span class="keyword">new</span> Game(), doom);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doomFullClone <span class="keyword">instanceof</span> Game); <span class="comment">// =&gt; true  </span></span><br><span class="line"><span class="built_in">console</span>.log(doomFullClone.name);            <span class="comment">// =&gt; "Doom"  </span></span><br><span class="line"><span class="built_in">console</span>.log(doomFullClone.getMessage());    <span class="comment">// =&gt; "I like Doom!"</span></span><br></pre></td></tr></table></figure><p>这样，就保留了原型。</p><h4 id="2-3-不可变对象更新"><a href="#2-3-不可变对象更新" class="headerlink" title="2.3 不可变对象更新"></a>2.3 不可变对象更新</h4><p>在一个应用里，同一个对象可能会用于多个地方，直接修改这个对象会带来意想不到的副作用，并且追踪这个修改及其困难。</p><p>一个好的方式是使操作不可变。不可变性使修改对象更为可控，更有利于书写。<a href="https://medium.com/@jamesjefferyuk/javascript-what-are-pure-functions-4d4d5392d49c" target="_blank" rel="noopener">pure functions</a>。即时是在复杂的应用场景，由于单向数据流，更容易确定对象的来源和改变的原因。</p><p>使用对象扩展能更方便的以不可变方式来修改一个对象。假设现在你有一个对象来描述一本书的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> book = &#123;  </span><br><span class="line">  name: <span class="string">'JavaScript: The Definitive Guide'</span>,</span><br><span class="line">  author: <span class="string">'David Flanagan'</span>,</span><br><span class="line">  edition: <span class="number">5</span>,</span><br><span class="line">  year: <span class="number">2008</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，书第六版即将出版，我们用对象扩展的处理这个场景。</p><p><a href="https://repl.it/@panzerdp/DistantWrongYak" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newerBook = &#123;  </span><br><span class="line">  ...book,</span><br><span class="line">  edition: <span class="number">6</span>,  <span class="comment">// &lt;----- Overwrites book.edition</span></span><br><span class="line">  year: <span class="number">2011</span>   <span class="comment">// &lt;----- Overwrites book.year</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newerBook);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: 'JavaScript: The Definitive Guide',</span></span><br><span class="line"><span class="comment">  author: 'David Flanagan',</span></span><br><span class="line"><span class="comment">  edition: 6,</span></span><br><span class="line"><span class="comment">  year: 2011</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>newerBook</code> 对象内的 <code>...book</code> 扩展了 <code>book</code> 对象的属性。手动创建的可枚举属性 <code>editon: 6</code> 和 <code>year: 2011</code> 更新了原有的同名属性。</p><p>重要的属性一般在末尾来指定，以便覆盖前面已经创建的同名属性。</p><p><code>newerBook</code> 是一个更新了某些属性的新的对象，并且我们没有改变原有的 <code>book</code> 对象，满足了不可变性的要求。</p><h4 id="2-4-合并对象"><a href="#2-4-合并对象" class="headerlink" title="2.4 合并对象"></a>2.4 合并对象</h4><p>使用对象扩展符合并多个对象非常简单。</p><p>现在我们合并3个对象来创建一个“合成对象”。</p><p><a href="https://repl.it/@panzerdp/LightseagreenMatureItaliangreyhound" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> part1 = &#123;  </span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> part2 = &#123;  </span><br><span class="line">  model: <span class="string">'Honda'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> part3 = &#123;  </span><br><span class="line">  year: <span class="number">2005</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = &#123;  </span><br><span class="line">  ...part1,</span><br><span class="line">  ...part2,</span><br><span class="line">  ...part3</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(car); <span class="comment">// &#123; color: 'white', model: 'Honda', year: 2005 &#125;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用 <code>part1</code>、<code>part2</code>、<code>part3</code> 3个对象合并成了一个 <code>car</code> 对象。</p><p>另外，不要忘了之前讲的规则，<code>后面的属性值会覆盖前面的同名属性值</code>。这是我们合并有同名属性对象的计算依据。</p><p>现在我们稍微改变一下之前的代码。给 <code>part1</code> 和 <code>part3</code> 增加一个 <code>.configuration</code> 属性。</p><p><a href="https://repl.it/@panzerdp/RuralUnkemptDrake" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> part1 = &#123;  </span><br><span class="line">  color: <span class="string">'white'</span>,</span><br><span class="line">  configuration: <span class="string">'sedan'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> part2 = &#123;  </span><br><span class="line">  model: <span class="string">'Honda'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> part3 = &#123;  </span><br><span class="line">  year: <span class="number">2005</span>,</span><br><span class="line">  configuration: <span class="string">'hatchback'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = &#123;  </span><br><span class="line">  ...part1,</span><br><span class="line">  ...part2,</span><br><span class="line">  ...part3 <span class="comment">// &lt;--- part3.configuration overwrites part1.configuration</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(car);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; </span></span><br><span class="line"><span class="comment">  color: 'white', </span></span><br><span class="line"><span class="comment">  model: 'Honda', </span></span><br><span class="line"><span class="comment">  year: 2005,</span></span><br><span class="line"><span class="comment">  configuration: 'hatchback'  `&lt;--- part3.configuration</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>...part1</code> 将 <code>configuration</code> 属性设置成了 <code>&#39;sedan&#39;</code>。然而之后的扩展符 <code>...part3</code> 覆盖了之前的同名 <code>.configuration</code>，最终生成的对象值为 <code>&#39;hatchback&#39;</code>。</p><h3 id="2-5-给对象设置默认值"><a href="#2-5-给对象设置默认值" class="headerlink" title="2.5 给对象设置默认值"></a>2.5 给对象设置默认值</h3><p>一个对象在程序运行时可能会有多套不同的属性值，有些属性可能会被设置，有些则可能被忽略。</p><p>这种情况通常发生在一个配置对象上。用户可以指定一个重要的属性值，不重要的属性则使用默认值。</p><p>现在我们来实现一个 <code>multline(str, config)</code> 方法，将<code>str</code> 按照给定的长度分割成多行。</p><p><code>config</code> 对象接受下面3个可选的参数。</p><ul><li><code>width</code>: 分割的字符长度，默认是 <code>10</code>。</li><li><code>newLine</code>: 添加到每一行结尾的的字符， 默认是 <code>\n</code>。</li><li><code>indent</code>: 每一行开头的缩进符，默认是空字符串 <code>&#39;&#39;</code>。</li></ul><p>下面是一些 <code>multline()</code> 运行的例子。</p><p><a href="https://repl.it/@panzerdp/FrankFirsthandBullfrog" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multiline(<span class="string">'Hello World!'</span>);  </span><br><span class="line"><span class="comment">// =&gt;` 'Hello Worl\nd!'</span></span><br><span class="line"></span><br><span class="line">multiline(<span class="string">'Hello World!'</span>, &#123; <span class="attr">width</span>: <span class="number">6</span> &#125;);  </span><br><span class="line"><span class="comment">// =&gt; 'Hello \nWorld!'</span></span><br><span class="line"></span><br><span class="line">multiline(<span class="string">'Hello World!'</span>, &#123; <span class="attr">width</span>: <span class="number">6</span>, <span class="attr">newLine</span>: <span class="string">'*'</span> &#125;);  </span><br><span class="line"><span class="comment">// =&gt; 'Hello *World!'</span></span><br><span class="line"></span><br><span class="line">multiline(<span class="string">'Hello World!'</span>, &#123; <span class="attr">width</span>: <span class="number">6</span>, <span class="attr">newLine</span>: <span class="string">'*'</span>, <span class="attr">indent</span>: <span class="string">'_'</span> &#125;);  </span><br><span class="line"><span class="comment">// =&gt; '_Hello *_World!'</span></span><br></pre></td></tr></table></figure><p><code>config</code> 参数接受几套不同的属性值：你可以指定1，2或者3个属性值，甚至不指定任何一个属性。</p><p>使用对象扩展语法来填充配置对象非常简单，在对象字面量里，首先扩展默认值对象，然后是配置对象，如下所示：</p><p><a href="https://repl.it/@panzerdp/FrankFirsthandBullfrog" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiline</span>(<span class="params">str, config = &#123;&#125;</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">const</span> defaultConfig = &#123;</span><br><span class="line">    width: <span class="number">10</span>,</span><br><span class="line">    newLine: <span class="string">'\n'</span>,</span><br><span class="line">    indent: <span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> safeConfig = &#123;</span><br><span class="line">    ...defaultConfig,</span><br><span class="line">    ...config</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// Implementation of multiline() using</span></span><br><span class="line">  <span class="comment">// safeConfig.width, safeConfig.newLine, safeConfig.indent</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来仔细了解一下 <code>safeConfig</code> 对象。</p><p><code>...defaultConfig</code> 首先将默认对象的属性复制，随后，<code>...config</code> 里用户自定义的值覆盖了之前的默认属性值。</p><p>这样 <code>safeConfig</code> 值就拥有了所有 <code>multiline()</code> 需要的配置参数。无论调用 <code>multiline()</code> 函数时，输入的 <code>config</code> 是否缺失了某些属性，都可以保证 <code>safeConfig</code> 拥有所有的必备参数。</p><p>显而易见，对象扩展实现了我们想要的 给对象设置默认值。</p><h4 id="2-6-更加深入"><a href="#2-6-更加深入" class="headerlink" title="2.6 更加深入"></a>2.6 更加深入</h4><p>对象扩展更有用的一点是用于嵌套对象，当更新一个复杂对象时，更具有可读性，比 <code>Object.assign()</code> 更值得推荐。</p><p>下面的 <code>box</code> 对象定义一个盒子及盒子内的物品。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = &#123;  </span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">  size: &#123;</span><br><span class="line">    width: <span class="number">200</span>, </span><br><span class="line">    height: <span class="number">100</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  items: [<span class="string">'pencil'</span>, <span class="string">'notebook'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>box.size</code> 描述了这个盒子的尺寸，<code>box.items</code> 列举了盒子内的物品。</p><p>为了使盒子看起来更高，我们增大 <code>box.size.height</code> 的值，只需要在嵌套对象上使用 <code>对象扩展符</code>。</p><p><a href="https://repl.it/@panzerdp/DemandingShoddyInsect" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> biggerBox = &#123;  </span><br><span class="line">  ...box,</span><br><span class="line">  size: &#123;</span><br><span class="line">    ...box.size,</span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(biggerBox);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  color: 'red',</span></span><br><span class="line"><span class="comment">  size: &#123;</span></span><br><span class="line"><span class="comment">    width: 200, </span></span><br><span class="line"><span class="comment">    height: 200 &lt;----- Updated value</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  items: ['pencil', 'notebook']</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>...box</code> 确保了 <code>biggerBox</code> 获得了 源对象 <code>box</code> 上的全部属性。</p><p>更新 <code>box.size</code> 的 height 值需要额外一个 <code>{...box.size, height: 200}</code> 对象，该对象接收 <code>box.size</code> 的全部属性，并将 height 值更新至 <code>200</code>。</p><p>只需要一个语句就能更新对象的多处属性。</p><p>现在如果我们还想把颜色改成 <code>black</code> ,增加盒子的宽度到 <code>400</code>, 并且再放一把尺子到盒子内，应该怎么办？同样很简单。</p><p><a href="https://repl.it/@panzerdp/ElectricLinearMayfly" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blackBox = &#123;  </span><br><span class="line">  ...box,</span><br><span class="line">  color: <span class="string">'black'</span>,</span><br><span class="line">  size: &#123;</span><br><span class="line">    ...box.size,</span><br><span class="line">    width: <span class="number">400</span></span><br><span class="line">  &#125;,</span><br><span class="line">  items: [</span><br><span class="line">    ...box.items,</span><br><span class="line">    <span class="string">'ruler'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(blackBox);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  color: 'black', &lt;----- Updated value</span></span><br><span class="line"><span class="comment">  size: &#123;</span></span><br><span class="line"><span class="comment">    width: 400, &lt;----- Updated value</span></span><br><span class="line"><span class="comment">    height: 100 </span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  items: ['pencil', 'notebook', 'ruler'] `&lt;----- A new item ruler</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-7-扩展-undefined、null-和-原始类型值"><a href="#2-7-扩展-undefined、null-和-原始类型值" class="headerlink" title="2.7 扩展 undefined、null 和 原始类型值"></a>2.7 扩展 <code>undefined</code>、<code>null</code> 和 <code>原始类型值</code></h4><p>如果在 <code>undefined</code>、<code>null</code> 和 <code>原始类型值</code> 上使用原始类型的值，不会复制任何属性，也不会抛出错误，只是简单的返回一个空对象。</p><p><a href="https://repl.it/@panzerdp/ForcefulFeminineKissingbug" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nothing = <span class="literal">undefined</span>;  </span><br><span class="line"><span class="keyword">const</span> missingObject = <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">const</span> two = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; ...nothing &#125;);       <span class="comment">// =&gt; &#123; &#125;  </span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; ...missingObject &#125;); <span class="comment">// =&gt; &#123; &#125;  </span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; ...two &#125;);           <span class="comment">// =&gt; &#123; &#125;</span></span><br></pre></td></tr></table></figure><p>如上所示：从 <code>nothing</code>, <code>missingObject</code> 和 <code>two</code>不会复制任何属性。</p><p>当然，这只是一个演示，毕竟根本没有理由在一个原始类型的值上面使用对象扩展符。</p><h4 id="3-剩余属性"><a href="#3-剩余属性" class="headerlink" title="3. 剩余属性"></a>3. 剩余属性</h4><p>当使用解构赋值将对象的属性值赋值给变量后，剩余的属性值将会被集合进一个剩余对象内。</p><p>下面的代码演示了怎么使用 rest 属性。</p><p><a href="https://repl.it/@panzerdp/PrimaryRawHagfish" target="_blank" rel="noopener">Run demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123;  </span><br><span class="line">  width: <span class="number">300</span>,</span><br><span class="line">  marginLeft: <span class="number">10</span>,</span><br><span class="line">  marginRight: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; width, ...margin &#125; = style;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(width);  <span class="comment">// =&gt; 300  </span></span><br><span class="line"><span class="built_in">console</span>.log(margin); <span class="comment">// =&gt; &#123; marginLeft: 10, marginRight: 30 &#125;</span></span><br></pre></td></tr></table></figure><p>通过解构赋值，我们定义了一个新的变量 <code>width</code> ，并将它的值设置为 <code>style.width</code>。而解构赋值声明内的 <code>...margin</code> 则获得了 <code>style</code> 对象的其余属性，<code>margin</code> 对象获取了 <code>marginLeft</code> 和 <code>marginRight</code> 属性。</p><p>rest 操作符同样只会获取自有属性和可枚举属性。</p><p>注意，在解构赋值内，rest 操作符只能放到最后，因此 <code>const { ...margin , width } = style</code> 无效，并会抛出一个 <code>SyntaxError: Rest element must be last element</code> 错误。</p><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h3><p>对象扩展需要以下几点：</p><ul><li>它只会提取对象的自有属性和可枚举属性</li><li>后定义的属性值会覆盖之前定义过的同名属性值</li></ul><p>同时，对象扩展使用上方便简洁，能更好的处理嵌套对象，保持不可变性，在实现对象克隆和填充默认属性值上也使用方便。</p><p>而 <code>rest</code> 操作符在解构赋值时可以收集剩余的属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合并多个 Javascript 对象是常见的工作，但不好的是，至少到目前，Javascript 仍然没有一种方便的方法来完成这个工作。至少现在是这样。&lt;/p&gt;
&lt;p&gt;在 ES5 时代，你可以使用 Lodash 的 &lt;code&gt;_.extend(target, [sources])&lt;/code&gt; 方法，而 ES2015 则引入了 &lt;code&gt;Object.assign(target, [sources])&lt;/code&gt; 方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>ES6 之 Symbol</title>
    <link href="http://yoursite.com/posts/9ced4e66/"/>
    <id>http://yoursite.com/posts/9ced4e66/</id>
    <published>2018-04-25T10:41:11.000Z</published>
    <updated>2018-05-07T12:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Symbol 是 ES6 增加的第7种数据类型，也是第6种原始数据类型。<br>symbol 值用来创建匿名的对象属性，同时也是唯一的，不会与其他属性名冲突。</p><a id="more"></a><h2 id="创建一个-symbol-值"><a href="#创建一个-symbol-值" class="headerlink" title="创建一个 symbol 值"></a>创建一个 symbol 值</h2><p>Symbol 是一个函数，调用这个函数即创建了一个 symbol 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>  <span class="comment">//function</span></span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure><p>但是 Symbol 不是一个构造函数，使用 new 来创建，会抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>Symbol 函数可以接受一个参数，用于描述这个 symbol ，但是也仅仅是用于描述而已<br>调用 toSring 方法可以读取到这个描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sym1) <span class="comment">// Symbol(hello world)</span></span><br></pre></td></tr></table></figure><p>即使传入完全一样的描述，所创建的 symbol 也是不相同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="使用-symbol"><a href="#使用-symbol" class="headerlink" title="使用 symbol"></a>使用 symbol</h2><p>symbol 用于对象属性时，不能使用点字符，只能用于计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'hello world'</span>)</span><br><span class="line">obj[sym] = <span class="string">'hello Symbol'</span></span><br></pre></td></tr></table></figure><h2 id="重复使用一个-symbol"><a href="#重复使用一个-symbol" class="headerlink" title="重复使用一个 symbol"></a>重复使用一个 symbol</h2><p>前面说过 每一个 symbol 值都是独一无二的，但是有时候我们也需要共用一个 symbol ，这时候就需要用到 <code>Symbol.for</code> 这一方法了。</p><p>Symbol.for 方法接受一个 key 参数，根据这个 key 在全局的 Symbol 注册值中查找，如果之前已经通过 Symbol.for 方法和该key 创建过，那么就返回这个已经创建的 symbol 值，否则以 key 值创建一个，并注册一个全局值。下面这个例子可以比较 <code>Symbol</code> 和 <code>Symbol.for</code> 的不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>)</span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sym3 === sym4) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当要创建 sym4 时，由于之前 已经用 global 这个值创建了 sym3 ，因此会直接把 sym3 的值赋给 sym4</p><p>和 Symbol.for 对应的另一个方法是 Symbol.keyFor<br>Symbol.keyFor 方法接受一个 symbol 值作为参数，返回对应的 key 值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sym3)) <span class="comment">// global</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sym4)) <span class="comment">// global</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(sym1)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>基本上，Symbol 了解这些就已经足够日常使用了。<br>剩下的一些零零散散的知识和一些 Well-known Symbol 之后抽空看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Symbol 是 ES6 增加的第7种数据类型，也是第6种原始数据类型。&lt;br&gt;symbol 值用来创建匿名的对象属性，同时也是唯一的，不会与其他属性名冲突。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
</feed>
